[["pytorch-and-numpy.html", "Chapter 1 PyTorch and NumPy 1.1 PyTorch modules in rTorch 1.2 Common array operations 1.3 Common tensor operations 1.4 Python built-in functions", " Chapter 1 PyTorch and NumPy Last update: Sun Oct 25 13:00:41 2020 -0500 (265c0b3c1) 1.1 PyTorch modules in rTorch 1.1.1 torchvision This is an example of using the torchvision module. With torchvision and its dataset set of function, we could download any of the popular datasets for machine learning made available by PyTorch. In this example, we will be downloading the training dataset of the MNIST handwritten digits. There are 60,000 images in the training set and 10,000 images in the test set. The images will download on the folder ./datasets, or any other you want, which can be set with the parameter root. library(rTorch) transforms &lt;- torchvision$transforms # this is the folder where the datasets will be downloaded local_folder &lt;- &#39;./datasets/mnist_digits&#39; train_dataset = torchvision$datasets$MNIST(root = local_folder, train = TRUE, transform = transforms$ToTensor(), download = TRUE) train_dataset #&gt; Dataset MNIST #&gt; Number of datapoints: 60000 #&gt; Root location: ./datasets/mnist_digits #&gt; Split: Train #&gt; StandardTransform #&gt; Transform: ToTensor() You can do similarly for the test dataset if you set the flag train = FALSE. The test dataset has only 10,000 images. test_dataset = torchvision$datasets$MNIST(root = local_folder, train = FALSE, transform = transforms$ToTensor()) test_dataset #&gt; Dataset MNIST #&gt; Number of datapoints: 10000 #&gt; Root location: ./datasets/mnist_digits #&gt; Split: Test #&gt; StandardTransform #&gt; Transform: ToTensor() 1.1.2 numpy numpy is automatically installed when PyTorch is. There is some interdependence between both. Anytime that we need to do some transformation that is not available in PyTorch, we will use numpy. Just keep in mind that numpy does not have support for GPUs; you will have to convert the numpy array to a torch tensor afterwards. 1.2 Common array operations There are several operations that we could perform with numpy such creating arrays: Create an array Create an array: # do some array manipulations with NumPy a &lt;- np$array(c(1:4)) a #&gt; [1] 1 2 3 4 We could do this if we add instead a Python chunk like this: {python} import numpy as np a = np.arange(1, 5) a import numpy as np a = np.arange(1, 5) a #&gt; array([1, 2, 3, 4]) Create an array of a desired shape: np$reshape(np$arange(0, 9), c(3L, 3L)) #&gt; [,1] [,2] [,3] #&gt; [1,] 0 1 2 #&gt; [2,] 3 4 5 #&gt; [3,] 6 7 8 Create an array by spelling out its components and type: np$array(list( list( 73, 67, 43), list( 87, 134, 58), list(102, 43, 37), list( 73, 67, 43), list( 91, 88, 64), list(102, 43, 37), list( 69, 96, 70), list( 91, 88, 64), list(102, 43, 37), list( 69, 96, 70) ), dtype=&#39;float32&#39;) #&gt; [,1] [,2] [,3] #&gt; [1,] 73 67 43 #&gt; [2,] 87 134 58 #&gt; [3,] 102 43 37 #&gt; [4,] 73 67 43 #&gt; [5,] 91 88 64 #&gt; [6,] 102 43 37 #&gt; [7,] 69 96 70 #&gt; [8,] 91 88 64 #&gt; [9,] 102 43 37 #&gt; [10,] 69 96 70 We will use the train and test datasets that we loaded with torchvision. Reshape an array For the same test dataset that we loaded above from MNIST digits, we will show the image of the handwritten digit and its label or class. Before plotting the image, we need to: Extract the image and label from the dataset Convert the tensor to a numpy array Reshape the tensor as a 2D array Plot the digit and its label rotate &lt;- function(x) t(apply(x, 2, rev)) # function to rotate the matrix # label for the image label &lt;- test_dataset[0][[2]] label # convert tensor to numpy array .show_img &lt;- test_dataset[0][[1]]$numpy() dim(.show_img) # reshape 3D array to 2D show_img &lt;- np$reshape(.show_img, c(28L, 28L)) dim(show_img) #&gt; [1] 7 #&gt; [1] 1 28 28 #&gt; [1] 28 28 We are simply using the r-base image function: # show in gray shades and rotate image(rotate(show_img), col = gray.colors(64)) title(label) Generate a random array in NumPy # set the seed np$random$seed(123L) # generate a random array x = np$random$rand(100L) dim(x) # calculate the y array y = np$sin(x) * np$power(x, 3L) + 3L * x + np$random$rand(100L) * 0.8 class(y) #&gt; [1] 100 #&gt; [1] &quot;array&quot; From the classes, we can tell that the numpy arrays are automatically converted to R arrays. Let’s plot x vs y: plot(x, y) 1.3 Common tensor operations Generate random tensors The same operation can be performed with pure torch tensors:. This is very similar to the example above. The only difference is that this time we are using tensors and not numpy arrays. library(rTorch) invisible(torch$manual_seed(123L)) x &lt;- torch$rand(100L) # use torch$randn(100L): positive and negative numbers y &lt;- torch$sin(x) * torch$pow(x, 3L) + 3L * x + torch$rand(100L) * 0.8 class(x) class(y) #&gt; [1] &quot;torch.Tensor&quot; &quot;torch._C._TensorBase&quot; &quot;python.builtin.object&quot; #&gt; [1] &quot;torch.Tensor&quot; &quot;torch._C._TensorBase&quot; &quot;python.builtin.object&quot; Since the classes are torch tensors, to plot them in R, they first need to be converted to numpy, and then to R: plot(x$numpy(), y$numpy()) numpy array to PyTorch tensor Converting a numpy array to a PyTorch tensor is a very common operation that I have seen in examples using PyTorch. Creating first the array in numpy. and then convert it to a torch tensor. # input array x = np$array(rbind( c(0,0,1), c(0,1,1), c(1,0,1), c(1,1,1))) # the numpy array x #&gt; [,1] [,2] [,3] #&gt; [1,] 0 0 1 #&gt; [2,] 0 1 1 #&gt; [3,] 1 0 1 #&gt; [4,] 1 1 1 This is another common operation that will find in the PyTorch tutorials: converting a numpy array from a certain type to a tensor of the same type: # convert the numpy array to a float type Xn &lt;- np$float32(x) # convert the numpy array to a float tensor Xt &lt;- torch$FloatTensor(Xn) Xt #&gt; tensor([[0., 0., 1.], #&gt; [0., 1., 1.], #&gt; [1., 0., 1.], #&gt; [1., 1., 1.]]) 1.4 Python built-in functions To access the Python built-in functions we make use of the package reticulate and the function import_builtins(). Here are part of the built-in functions and operators offered by the R package reticulate. I am using the R function grep() to discard those which carry the keywords Error, or Warning, or Exit. py_bi &lt;- reticulate::import_builtins() grep(&quot;Error|Warning|Exit&quot;, names(py_bi), value = TRUE, invert = TRUE, perl = TRUE) #&gt; [1] &quot;abs&quot; &quot;all&quot; &quot;any&quot; #&gt; [4] &quot;ascii&quot; &quot;BaseException&quot; &quot;bin&quot; #&gt; [7] &quot;bool&quot; &quot;breakpoint&quot; &quot;bytearray&quot; #&gt; [10] &quot;bytes&quot; &quot;callable&quot; &quot;chr&quot; #&gt; [13] &quot;classmethod&quot; &quot;compile&quot; &quot;complex&quot; #&gt; [16] &quot;copyright&quot; &quot;credits&quot; &quot;delattr&quot; #&gt; [19] &quot;dict&quot; &quot;dir&quot; &quot;divmod&quot; #&gt; [22] &quot;Ellipsis&quot; &quot;enumerate&quot; &quot;eval&quot; #&gt; [25] &quot;Exception&quot; &quot;exec&quot; &quot;exit&quot; #&gt; [28] &quot;False&quot; &quot;filter&quot; &quot;float&quot; #&gt; [31] &quot;format&quot; &quot;frozenset&quot; &quot;getattr&quot; #&gt; [34] &quot;globals&quot; &quot;hasattr&quot; &quot;hash&quot; #&gt; [37] &quot;help&quot; &quot;hex&quot; &quot;id&quot; #&gt; [40] &quot;input&quot; &quot;int&quot; &quot;isinstance&quot; #&gt; [43] &quot;issubclass&quot; &quot;iter&quot; &quot;KeyboardInterrupt&quot; #&gt; [46] &quot;len&quot; &quot;license&quot; &quot;list&quot; #&gt; [49] &quot;locals&quot; &quot;map&quot; &quot;max&quot; #&gt; [52] &quot;memoryview&quot; &quot;min&quot; &quot;next&quot; #&gt; [55] &quot;None&quot; &quot;NotImplemented&quot; &quot;object&quot; #&gt; [58] &quot;oct&quot; &quot;open&quot; &quot;ord&quot; #&gt; [61] &quot;pow&quot; &quot;print&quot; &quot;property&quot; #&gt; [64] &quot;quit&quot; &quot;range&quot; &quot;repr&quot; #&gt; [67] &quot;reversed&quot; &quot;round&quot; &quot;set&quot; #&gt; [70] &quot;setattr&quot; &quot;slice&quot; &quot;sorted&quot; #&gt; [73] &quot;staticmethod&quot; &quot;StopAsyncIteration&quot; &quot;StopIteration&quot; #&gt; [76] &quot;str&quot; &quot;sum&quot; &quot;super&quot; #&gt; [79] &quot;True&quot; &quot;tuple&quot; &quot;type&quot; #&gt; [82] &quot;vars&quot; &quot;zip&quot; Length of a dataset Sometimes, we will need the Python len function to find out the length of an object: py_bi$len(train_dataset) py_bi$len(test_dataset) #&gt; [1] 60000 #&gt; [1] 10000 Iterators Iterators are used a lot in dataset operations when running a neural network. In this example we will iterate through only 100 elements of the 60,000 of the MNIST train dataset. The goal is printing the “label” or “class” for the digits we are reading. The digits are not show here; they are stored in tensors. # iterate through training dataset enum_train_dataset &lt;- py_bi$enumerate(train_dataset) cat(sprintf(&quot;%8s %8s \\n&quot;, &quot;index&quot;, &quot;label&quot;)) for (i in 1:py_bi$len(train_dataset)) { obj &lt;- reticulate::iter_next(enum_train_dataset) idx &lt;- obj[[1]] # index number cat(sprintf(&quot;%8d %5d \\n&quot;, idx, obj[[2]][[2]])) if (i &gt;= 100) break # print only 100 labels } #&gt; index label #&gt; 0 5 #&gt; 1 0 #&gt; 2 4 #&gt; 3 1 #&gt; 4 9 #&gt; 5 2 #&gt; 6 1 #&gt; 7 3 #&gt; 8 1 #&gt; 9 4 #&gt; 10 3 #&gt; 11 5 #&gt; 12 3 #&gt; 13 6 #&gt; 14 1 #&gt; 15 7 #&gt; 16 2 #&gt; 17 8 #&gt; 18 6 #&gt; 19 9 #&gt; 20 4 #&gt; 21 0 #&gt; 22 9 #&gt; 23 1 #&gt; 24 1 #&gt; 25 2 #&gt; 26 4 #&gt; 27 3 #&gt; 28 2 #&gt; 29 7 #&gt; 30 3 #&gt; 31 8 #&gt; 32 6 #&gt; 33 9 #&gt; 34 0 #&gt; 35 5 #&gt; 36 6 #&gt; 37 0 #&gt; 38 7 #&gt; 39 6 #&gt; 40 1 #&gt; 41 8 #&gt; 42 7 #&gt; 43 9 #&gt; 44 3 #&gt; 45 9 #&gt; 46 8 #&gt; 47 5 #&gt; 48 9 #&gt; 49 3 #&gt; 50 3 #&gt; 51 0 #&gt; 52 7 #&gt; 53 4 #&gt; 54 9 #&gt; 55 8 #&gt; 56 0 #&gt; 57 9 #&gt; 58 4 #&gt; 59 1 #&gt; 60 4 #&gt; 61 4 #&gt; 62 6 #&gt; 63 0 #&gt; 64 4 #&gt; 65 5 #&gt; 66 6 #&gt; 67 1 #&gt; 68 0 #&gt; 69 0 #&gt; 70 1 #&gt; 71 7 #&gt; 72 1 #&gt; 73 6 #&gt; 74 3 #&gt; 75 0 #&gt; 76 2 #&gt; 77 1 #&gt; 78 1 #&gt; 79 7 #&gt; 80 9 #&gt; 81 0 #&gt; 82 2 #&gt; 83 6 #&gt; 84 7 #&gt; 85 8 #&gt; 86 3 #&gt; 87 9 #&gt; 88 0 #&gt; 89 4 #&gt; 90 6 #&gt; 91 7 #&gt; 92 4 #&gt; 93 6 #&gt; 94 8 #&gt; 95 0 #&gt; 96 7 #&gt; 97 8 #&gt; 98 3 #&gt; 99 1 Types and instances Types, instances and classes are important to take decisions on how we will process data that is being read from the datasets. In this example, we want to know if an object is of certain instance: # get the class of the object py_bi$type(train_dataset) # is train_dataset a torchvision dataset class py_bi$isinstance(train_dataset, torchvision$datasets$mnist$MNIST) #&gt; &lt;class &#39;torchvision.datasets.mnist.MNIST&#39;&gt; #&gt; [1] TRUE "]]

[["index.html", "A Minimal rTorch Book Prerequisites Installation Python Anaconda", " A Minimal rTorch Book Alfonso R. Reyes 2020-10-22 Prerequisites Last update: Thu Oct 22 19:48:06 2020 -0500 (1c61420f8) You need couple of things to get rTorch working: Install Python Anaconda. Preferrably, for 64-bits, and above Python 3.6+. I have successfully tested Anaconda under four different operating systems: Windows (Win10 and Windows Server 2008); macOS (Sierra, Mojave and Catalina); Linux (Debian, Fedora and Ubuntu); and lastly, Solaris 10. ASll these tests are required by CRAN. Install R, Rtools and RStudio. Install the R package reticulate, which is the one that provides the connection between R and Python. Install the stable version rTorch from CRAN, or the latest version under develoipment via GitHub. Note. While it is not mandatory to have a previously created Python environment with Anaconda, where PyTorch and TorchVision have already been installed, it is another option if for some reason reticulate refuses to communicate with the conda environment. Keep in mind that you could also get the rTorch conda environment installed directly from the R console, in very similar fashion as in R-TensorFlow using the function install_pytorch(). Installation The rTorch package can be installed from CRAN or Github. From CRAN: install.packages(&quot;rTorch&quot;) From GitHub, install rTorch with: devtools::install_github(&quot;f0nzie/rTorch&quot;) which will install rTorch from the main or master branch. To install it from the develop branch, you type this: devtools::install_github(&quot;f0nzie/rTorch&quot;, ref=&quot;develop&quot;) or clone with Git with: git clone https://github.com/f0nzie/rTorch.git This will allow you to build rTorch from source. Python Anaconda If your preference is installing an Anaconda environment first, these are the steps: Example Create a conda environment from the terminal with conda create -n r-torch python=3.7 Activate the new environment with conda activate r-torch Install the PyTorch related packages with: conda install python=3.6.6 pytorch torchvision cpuonly matplotlib pandas -c pytorch The last part -c pytorch specifies the stable conda channel to download the PyTorch packages. Your conda installation may not work if you don’t indicate the channel. Now, you can load rTorch in R or RStudio with: library(rTorch) Automatic installation I used the idea for automatic installation in the tensorflow package for R, to create the function rTorch::install_pytorch(). This function will allow you to install a conda environment complete with all PyTorch requirements plus the packages you specify. Example: rTorch:::install_conda(package=&quot;pytorch=1.4&quot;, envname=&quot;r-torch&quot;, conda=&quot;auto&quot;, conda_python_version = &quot;3.6&quot;, pip=FALSE, channel=&quot;pytorch&quot;, extra_packages=c(&quot;torchvision&quot;, &quot;cpuonly&quot;, &quot;matplotlib&quot;, &quot;pandas&quot;)) This is explained in more detailed in the rTorch package manual. Note. matplotlib and pandas are not really necessary for rTorch to work, but I was asked if matplotlib or pandas could work with PyTorch. So, I decided to install them for testing and experimentation. They both work. "],["intro.html", "Chapter 1 Introduction 1.1 Motivation 1.2 Start using rTorch 1.3 What can you do with rTorch 1.4 Getting help", " Chapter 1 Introduction Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 1.1 Motivation Why do we want a package of something that is already working well, such as PyTorch? There are several reasons, but the main one is to bring another machine learning framework to R. Probably it is just me but I feel PyTorch very comfortable to work with. Feels pretty much like everything else in Python. Very Pythonic. I have tried other frameworks in R. The closest that matches a natural language like PyTorch, is MXnet. Unfortunately, MXnet it is the hardest to install and maintain after updates. Yes. I could have worked directly with PyTorch in a native Python environment, such as Jupyter or PyCharm or vscode notebooks but it very hard to quit RMarkdown once you get used to it. It is the real thing in regards to literate programmingand reproducibility. It does not only contribute to improving the quality of the code but establishes a workflow for a better understanding of a subject by your intended readers (Knuth 1983), in what is been called the literate programming paradigm (Cordes and Brown 1991). This has the additional benefit of giving the ability to write combination of Python and R code together in the same document. There will times when it is better to create a class in Python; and other times where R will be more convenient to handle a data structure. I show some examples using data.frame and data.table along with PyTorch tensors. 1.2 Start using rTorch Start using rTorch is very simple. After installing the minimum system requirements -such as conda- you just call it with: library(rTorch) There are several way of testing if rTorch is up and running. Let’s see some of them: 1.2.1 Get the PyTorch version rTorch::torch_version() #&gt; [1] &quot;1.6&quot; 1.2.2 PyTorch configuration This will show the PyTorch version and the current version of Python installed, as well as the paths to folders where they reside. rTorch::torch_config() #&gt; PyTorch v1.6.0 (~/anaconda3/envs/r-torch/lib/python3.7/site-packages/torch) #&gt; Python v3.7 (~/anaconda3/envs/r-torch/bin/python) #&gt; NumPy v1.19.1) 1.3 What can you do with rTorch Practically, you can do everything you could with PyTorch within the R ecosystem. Additionally to the rTorch module, from where you can extract methods, functions and classes, there are available two more modules: torchvision and np, which is short for numpy. We could use the modules with: rTorch::torchvision rTorch::np rTorch::torch #&gt; Module(torchvision) #&gt; Module(numpy) #&gt; Module(torch) 1.4 Getting help We get a glimpse of the first lines of the help(\"torch\") via a Python chunk: help(&quot;torch&quot;) ... #&gt; NAME #&gt; torch #&gt; #&gt; DESCRIPTION #&gt; The torch package contains data structures for multi-dimensional #&gt; tensors and mathematical operations over these are defined. #&gt; Additionally, it provides many utilities for efficient serializing of #&gt; Tensors and arbitrary types, and other useful utilities. ... help(&quot;torch.tensor&quot;) ... #&gt; Help on built-in function tensor in torch: #&gt; #&gt; torch.tensor = tensor(...) #&gt; tensor(data, dtype=None, device=None, requires_grad=False, pin_memory=False) -&gt; Tensor #&gt; #&gt; Constructs a tensor with :attr:`data`. #&gt; #&gt; .. warning:: #&gt; #&gt; :func:`torch.tensor` always copies :attr:`data`. If you have a Tensor #&gt; ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_` #&gt; or :func:`torch.Tensor.detach`. #&gt; If you have a NumPy ``ndarray`` and want to avoid a copy, use #&gt; :func:`torch.as_tensor`. #&gt; #&gt; .. warning:: #&gt; #&gt; When data is a tensor `x`, :func:`torch.tensor` reads out &#39;the data&#39; from whatever it is passed, #&gt; and constructs a leaf variable. Therefore ``torch.tensor(x)`` is equivalent to ``x.clone().detach()`` #&gt; and ``torch.tensor(x, requires_grad=True)`` is equivalent to ``x.clone().detach().requires_grad_(True)``. ... help(&quot;torch.cat&quot;) ... #&gt; Help on built-in function cat in torch: #&gt; #&gt; torch.cat = cat(...) #&gt; cat(tensors, dim=0, out=None) -&gt; Tensor #&gt; #&gt; Concatenates the given sequence of :attr:`seq` tensors in the given dimension. #&gt; All tensors must either have the same shape (except in the concatenating #&gt; dimension) or be empty. #&gt; #&gt; :func:`torch.cat` can be seen as an inverse operation for :func:`torch.split` #&gt; and :func:`torch.chunk`. #&gt; #&gt; :func:`torch.cat` can be best understood via examples. #&gt; #&gt; Args: #&gt; tensors (sequence of Tensors): any python sequence of tensors of the same type. #&gt; Non-empty tensors provided must have the same shape, except in the #&gt; cat dimension. #&gt; dim (int, optional): the dimension over which the tensors are concatenated #&gt; out (Tensor, optional): the output tensor. ... help(&quot;numpy.arange&quot;) ... #&gt; Help on built-in function arange in numpy: #&gt; #&gt; numpy.arange = arange(...) #&gt; arange([start,] stop[, step,], dtype=None) #&gt; #&gt; Return evenly spaced values within a given interval. #&gt; #&gt; Values are generated within the half-open interval ``[start, stop)`` #&gt; (in other words, the interval including `start` but excluding `stop`). #&gt; For integer arguments the function is equivalent to the Python built-in #&gt; `range` function, but returns an ndarray rather than a list. #&gt; #&gt; When using a non-integer step, such as 0.1, the results will often not #&gt; be consistent. It is better to use `numpy.linspace` for these cases. #&gt; #&gt; Parameters #&gt; ---------- #&gt; start : number, optional #&gt; Start of interval. The interval includes this value. The default #&gt; start value is 0. #&gt; stop : number #&gt; End of interval. The interval does not include this value, except #&gt; in some cases where `step` is not an integer and floating point #&gt; round-off affects the length of `out`. #&gt; step : number, optional ... Finally, these are the classes for the module torchvision.datasets. We are using Python to list them using the help function. help(&quot;torchvision.datasets&quot;) ... #&gt; Help on package torchvision.datasets in torchvision: #&gt; #&gt; NAME #&gt; torchvision.datasets #&gt; #&gt; PACKAGE CONTENTS #&gt; caltech #&gt; celeba #&gt; cifar #&gt; cityscapes #&gt; coco #&gt; fakedata #&gt; flickr #&gt; folder #&gt; hmdb51 #&gt; imagenet #&gt; kinetics #&gt; lsun #&gt; mnist #&gt; omniglot #&gt; phototour #&gt; samplers (package) #&gt; sbd #&gt; sbu #&gt; semeion #&gt; stl10 #&gt; svhn #&gt; ucf101 #&gt; usps #&gt; utils #&gt; video_utils #&gt; vision #&gt; voc #&gt; #&gt; CLASSES ... In other words, all the functions, modules, classes in PyTorch are available to rTorch. "],["pytorch-and-numpy.html", "Chapter 2 PyTorch and NumPy 2.1 PyTorch modules in rTorch 2.2 Common array operations 2.3 Common tensor operations 2.4 Python built-in functions", " Chapter 2 PyTorch and NumPy Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 2.1 PyTorch modules in rTorch 2.1.1 torchvision This is an example of using the torchvision module. With torchvision we could download any of the datasets made available by PyTorch. In this example, we will be downloading the training dataset of the MNIST handwritten digits. There are 60,000 images in the training set and 10,000 images in the test set. The images will download on the folder ./datasets. library(rTorch) transforms &lt;- torchvision$transforms # this is the folder where the datasets will be downloaded local_folder &lt;- &#39;./datasets/mnist_digits&#39; train_dataset = torchvision$datasets$MNIST(root = local_folder, train = TRUE, transform = transforms$ToTensor(), download = TRUE) train_dataset #&gt; Dataset MNIST #&gt; Number of datapoints: 60000 #&gt; Root location: ./datasets/mnist_digits #&gt; Split: Train #&gt; StandardTransform #&gt; Transform: ToTensor() You can do similarly for the test dataset if you set the flag train = FALSE. The test dataset has only 10,000 images. test_dataset = torchvision$datasets$MNIST(root = local_folder, train = FALSE, transform = transforms$ToTensor()) test_dataset #&gt; Dataset MNIST #&gt; Number of datapoints: 10000 #&gt; Root location: ./datasets/mnist_digits #&gt; Split: Test #&gt; StandardTransform #&gt; Transform: ToTensor() 2.1.2 numpy numpy is automaticaly installed when PyTorch is. There is some interdependence between both. Anytime that we need to do some transformation that is not available in PyTorch, we will use numpy. Just keep in mind that numpy does not have support for GPUs. 2.2 Common array operations There are several operations that we could perform with numpy such creating arrays: Create an array Create an array: # do some array manipulations with NumPy a &lt;- np$array(c(1:4)) a #&gt; [1] 1 2 3 4 Create an array of a desired shape: np$reshape(np$arange(0, 9), c(3L, 3L)) #&gt; [,1] [,2] [,3] #&gt; [1,] 0 1 2 #&gt; [2,] 3 4 5 #&gt; [3,] 6 7 8 Create an array by spelling out its components and type: np$array(list( list(73, 67, 43), list(87, 134, 58), list(102, 43, 37), list(73, 67, 43), list(91, 88, 64), list(102, 43, 37), list(69, 96, 70), list(91, 88, 64), list(102, 43, 37), list(69, 96, 70) ), dtype=&#39;float32&#39;) #&gt; [,1] [,2] [,3] #&gt; [1,] 73 67 43 #&gt; [2,] 87 134 58 #&gt; [3,] 102 43 37 #&gt; [4,] 73 67 43 #&gt; [5,] 91 88 64 #&gt; [6,] 102 43 37 #&gt; [7,] 69 96 70 #&gt; [8,] 91 88 64 #&gt; [9,] 102 43 37 #&gt; [10,] 69 96 70 We will use the train and test datasets that we loaded with torchvision. Reshape an array For the same test dataset that we loaded above from MNIST digits, we will show the image of the handwritten digit and its label or class. Before plotting the image, we need to: Extract the image and label from the dataset Convert the tensor to a numpy array Reshape the tensor as a 2D array Plot the digit and its label rotate &lt;- function(x) t(apply(x, 2, rev)) # function to rotate the matrix # label for the image label &lt;- test_dataset[0][[2]] label # convert tensor to numpy array .show_img &lt;- test_dataset[0][[1]]$numpy() dim(.show_img) # reshape 3D array to 2D show_img &lt;- np$reshape(.show_img, c(28L, 28L)) dim(show_img) #&gt; [1] 7 #&gt; [1] 1 28 28 #&gt; [1] 28 28 # show in gray shades and rotate image(rotate(show_img), col = gray.colors(64)) title(label) Generate a random array in NumPy # set the seed np$random$seed(123L) # generate a random array x = np$random$rand(100L) x # calculate the y array y = np$sin(x) * np$power(x, 3L) + 3L * x + np$random$rand(100L) * 0.8 class(x) class(y) #&gt; [1] 0.6965 0.2861 0.2269 0.5513 0.7195 0.4231 0.9808 0.6848 0.4809 0.3921 #&gt; [11] 0.3432 0.7290 0.4386 0.0597 0.3980 0.7380 0.1825 0.1755 0.5316 0.5318 #&gt; [21] 0.6344 0.8494 0.7245 0.6110 0.7224 0.3230 0.3618 0.2283 0.2937 0.6310 #&gt; [31] 0.0921 0.4337 0.4309 0.4937 0.4258 0.3123 0.4264 0.8934 0.9442 0.5018 #&gt; [41] 0.6240 0.1156 0.3173 0.4148 0.8663 0.2505 0.4830 0.9856 0.5195 0.6129 #&gt; [51] 0.1206 0.8263 0.6031 0.5451 0.3428 0.3041 0.4170 0.6813 0.8755 0.5104 #&gt; [61] 0.6693 0.5859 0.6249 0.6747 0.8423 0.0832 0.7637 0.2437 0.1942 0.5725 #&gt; [71] 0.0957 0.8853 0.6272 0.7234 0.0161 0.5944 0.5568 0.1590 0.1531 0.6955 #&gt; [81] 0.3188 0.6920 0.5544 0.3890 0.9251 0.8417 0.3574 0.0436 0.3048 0.3982 #&gt; [91] 0.7050 0.9954 0.3559 0.7625 0.5932 0.6917 0.1511 0.3989 0.2409 0.3435 #&gt; [1] &quot;array&quot; #&gt; [1] &quot;array&quot; From the classes, we can tell that the numpy arrays are automatically converted to R arrays. plot(x, y) 2.3 Common tensor operations Generate random tensors The same operation can be performed with pure torch tensors: library(rTorch) invisible(torch$manual_seed(123L)) x &lt;- torch$rand(100L) # use torch$randn(100L): positive and negative numbers y &lt;- torch$sin(x) * torch$pow(x, 3L) + 3L * x + torch$rand(100L) * 0.8 class(x) class(y) #&gt; [1] &quot;torch.Tensor&quot; &quot;torch._C._TensorBase&quot; &quot;python.builtin.object&quot; #&gt; [1] &quot;torch.Tensor&quot; &quot;torch._C._TensorBase&quot; &quot;python.builtin.object&quot; Since the clasess are torch tensors, to plot them in R, they need to be converted to numpy, and then R: plot(x$numpy(), y$numpy()) numpy array to PyTorch tensor Converting a numpy array to a PyTorch tensor is a very common operation that I have seen in examples using PyTorch. Creating first the array in numpy. and then convert it to a torch tensor. # input array x = np$array(rbind( c(0,0,1), c(0,1,1), c(1,0,1), c(1,1,1))) # the numpy array x #&gt; [,1] [,2] [,3] #&gt; [1,] 0 0 1 #&gt; [2,] 0 1 1 #&gt; [3,] 1 0 1 #&gt; [4,] 1 1 1 This is another common operation that will find in the PyTorch tutorials: converting a numpy array from a certain type to a tensor of the same type: # convert the numpy array to a float type Xn &lt;- np$float32(x) # convert the numpy array to a float tensor Xt &lt;- torch$FloatTensor(Xn) Xt #&gt; tensor([[0., 0., 1.], #&gt; [0., 1., 1.], #&gt; [1., 0., 1.], #&gt; [1., 1., 1.]]) 2.4 Python built-in functions To access the Python built-in functions we make use of the package reticulate and the function import_builtins(). Here are part of the built-in functions and operators offered by reticulate: py_bi &lt;- import_builtins() grep(&quot;Error|Warning|Exit&quot;, names(py_bi), value = TRUE, invert = TRUE, perl = TRUE) #&gt; [1] &quot;abs&quot; &quot;all&quot; &quot;any&quot; #&gt; [4] &quot;ascii&quot; &quot;BaseException&quot; &quot;bin&quot; #&gt; [7] &quot;bool&quot; &quot;breakpoint&quot; &quot;bytearray&quot; #&gt; [10] &quot;bytes&quot; &quot;callable&quot; &quot;chr&quot; #&gt; [13] &quot;classmethod&quot; &quot;compile&quot; &quot;complex&quot; #&gt; [16] &quot;copyright&quot; &quot;credits&quot; &quot;delattr&quot; #&gt; [19] &quot;dict&quot; &quot;dir&quot; &quot;divmod&quot; #&gt; [22] &quot;Ellipsis&quot; &quot;enumerate&quot; &quot;eval&quot; #&gt; [25] &quot;Exception&quot; &quot;exec&quot; &quot;exit&quot; #&gt; [28] &quot;False&quot; &quot;filter&quot; &quot;float&quot; #&gt; [31] &quot;format&quot; &quot;frozenset&quot; &quot;getattr&quot; #&gt; [34] &quot;globals&quot; &quot;hasattr&quot; &quot;hash&quot; #&gt; [37] &quot;help&quot; &quot;hex&quot; &quot;id&quot; #&gt; [40] &quot;input&quot; &quot;int&quot; &quot;isinstance&quot; #&gt; [43] &quot;issubclass&quot; &quot;iter&quot; &quot;KeyboardInterrupt&quot; #&gt; [46] &quot;len&quot; &quot;license&quot; &quot;list&quot; #&gt; [49] &quot;locals&quot; &quot;map&quot; &quot;max&quot; #&gt; [52] &quot;memoryview&quot; &quot;min&quot; &quot;next&quot; #&gt; [55] &quot;None&quot; &quot;NotImplemented&quot; &quot;object&quot; #&gt; [58] &quot;oct&quot; &quot;open&quot; &quot;ord&quot; #&gt; [61] &quot;pow&quot; &quot;print&quot; &quot;property&quot; #&gt; [64] &quot;quit&quot; &quot;range&quot; &quot;repr&quot; #&gt; [67] &quot;reversed&quot; &quot;round&quot; &quot;set&quot; #&gt; [70] &quot;setattr&quot; &quot;slice&quot; &quot;sorted&quot; #&gt; [73] &quot;staticmethod&quot; &quot;StopAsyncIteration&quot; &quot;StopIteration&quot; #&gt; [76] &quot;str&quot; &quot;sum&quot; &quot;super&quot; #&gt; [79] &quot;True&quot; &quot;tuple&quot; &quot;type&quot; #&gt; [82] &quot;vars&quot; &quot;zip&quot; Length of a dataset Sometimes, we will need the Python len function to find out the length of an object: py_bi$len(train_dataset) py_bi$len(test_dataset) #&gt; [1] 60000 #&gt; [1] 10000 Iterators Iterators are used a lot in dataset operations when running a neural network. In this example we will iterate through only 100 elements of the 60,000 of the train dataset. The goal is printing the “label” or “class” for the digits we are reading. The digits are not show here; they are stored in tensors. # iterate through training dataset enum_train_dataset &lt;- py_bi$enumerate(train_dataset) cat(sprintf(&quot;%8s %8s \\n&quot;, &quot;index&quot;, &quot;label&quot;)) for (i in 1:py_bi$len(train_dataset)) { obj &lt;- reticulate::iter_next(enum_train_dataset) idx &lt;- obj[[1]] # index number cat(sprintf(&quot;%8d %5d \\n&quot;, idx, obj[[2]][[2]])) if (i &gt;= 100) break # print only 100 labels } #&gt; index label #&gt; 0 5 #&gt; 1 0 #&gt; 2 4 #&gt; 3 1 #&gt; 4 9 #&gt; 5 2 #&gt; 6 1 #&gt; 7 3 #&gt; 8 1 #&gt; 9 4 #&gt; 10 3 #&gt; 11 5 #&gt; 12 3 #&gt; 13 6 #&gt; 14 1 #&gt; 15 7 #&gt; 16 2 #&gt; 17 8 #&gt; 18 6 #&gt; 19 9 #&gt; 20 4 #&gt; 21 0 #&gt; 22 9 #&gt; 23 1 #&gt; 24 1 #&gt; 25 2 #&gt; 26 4 #&gt; 27 3 #&gt; 28 2 #&gt; 29 7 #&gt; 30 3 #&gt; 31 8 #&gt; 32 6 #&gt; 33 9 #&gt; 34 0 #&gt; 35 5 #&gt; 36 6 #&gt; 37 0 #&gt; 38 7 #&gt; 39 6 #&gt; 40 1 #&gt; 41 8 #&gt; 42 7 #&gt; 43 9 #&gt; 44 3 #&gt; 45 9 #&gt; 46 8 #&gt; 47 5 #&gt; 48 9 #&gt; 49 3 #&gt; 50 3 #&gt; 51 0 #&gt; 52 7 #&gt; 53 4 #&gt; 54 9 #&gt; 55 8 #&gt; 56 0 #&gt; 57 9 #&gt; 58 4 #&gt; 59 1 #&gt; 60 4 #&gt; 61 4 #&gt; 62 6 #&gt; 63 0 #&gt; 64 4 #&gt; 65 5 #&gt; 66 6 #&gt; 67 1 #&gt; 68 0 #&gt; 69 0 #&gt; 70 1 #&gt; 71 7 #&gt; 72 1 #&gt; 73 6 #&gt; 74 3 #&gt; 75 0 #&gt; 76 2 #&gt; 77 1 #&gt; 78 1 #&gt; 79 7 #&gt; 80 9 #&gt; 81 0 #&gt; 82 2 #&gt; 83 6 #&gt; 84 7 #&gt; 85 8 #&gt; 86 3 #&gt; 87 9 #&gt; 88 0 #&gt; 89 4 #&gt; 90 6 #&gt; 91 7 #&gt; 92 4 #&gt; 93 6 #&gt; 94 8 #&gt; 95 0 #&gt; 96 7 #&gt; 97 8 #&gt; 98 3 #&gt; 99 1 Types and instances Types, instances and classes are important to take decisions on how we will process data that is being read from the datasets. In this example, we want to know if an object is of certain instance: # get the class of the object py_bi$type(train_dataset) # is train_dataset a torchvision dataset class py_bi$isinstance(train_dataset, torchvision$datasets$mnist$MNIST) #&gt; &lt;class &#39;torchvision.datasets.mnist.MNIST&#39;&gt; #&gt; [1] TRUE "],["rtorch-vs-pytorch.html", "Chapter 3 rTorch vs PyTorch 3.1 What’s different 3.2 Calling objects from PyTorch 3.3 Call functions from torch 3.4 Python objects 3.5 Iterating through datasets 3.6 Zero gradient 3.7 R generic functions", " Chapter 3 rTorch vs PyTorch Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 3.1 What’s different This chapter will explain the main differences between PyTorch and rTorch. Most of the things work directly in PyTorch but we need to be aware of some minor differences when working with rTorch. Here is a review of existing methods. Let’s start by loading rTorch: library(rTorch) 3.2 Calling objects from PyTorch We use the dollar sign or $ to call a class, function or method from the rTorch modules. In this case, from the torch module: torch$tensor(c(1, 2, 3)) #&gt; tensor([1., 2., 3.]) In Python, what we do is using the dot to separate the sub-members of an object: import torch torch.tensor([1, 2, 3]) #&gt; tensor([1, 2, 3]) 3.3 Call functions from torch library(rTorch) # these are the equivalents of the Python import module nn &lt;- torch$nn transforms &lt;- torchvision$transforms dsets &lt;- torchvision$datasets torch$tensor(c(1, 2, 3)) #&gt; tensor([1., 2., 3.]) The code above is equivalent to writing this code in Python: import torch import torch.nn as nn import torchvision.transforms as transforms import torchvision.datasets as dsets torch.tensor([1, 2, 3]) #&gt; tensor([1, 2, 3]) Then we can proceed to extract classes, methods and functions from the nn, transforms, and dsets objects. In this example we use the module torchvision$datasets and the function transforms$ToTensor() local_folder &lt;- &#39;./datasets/mnist_digits&#39; train_dataset = torchvision$datasets$MNIST(root = local_folder, train = TRUE, transform = transforms$ToTensor(), download = TRUE) train_dataset #&gt; Dataset MNIST #&gt; Number of datapoints: 60000 #&gt; Root location: ./datasets/mnist_digits #&gt; Split: Train #&gt; StandardTransform #&gt; Transform: ToTensor() 3.4 Python objects Sometimes we are interested in knowing the internal components of a class. In that case, we use the reticulate function py_list_attributes(). In this example, we want to show the attributes of train_dataset: reticulate::py_list_attributes(train_dataset) #&gt; [1] &quot;__add__&quot; &quot;__class__&quot; &quot;__delattr__&quot; #&gt; [4] &quot;__dict__&quot; &quot;__dir__&quot; &quot;__doc__&quot; #&gt; [7] &quot;__eq__&quot; &quot;__format__&quot; &quot;__ge__&quot; #&gt; [10] &quot;__getattribute__&quot; &quot;__getitem__&quot; &quot;__gt__&quot; #&gt; [13] &quot;__hash__&quot; &quot;__init__&quot; &quot;__init_subclass__&quot; #&gt; [16] &quot;__le__&quot; &quot;__len__&quot; &quot;__lt__&quot; #&gt; [19] &quot;__module__&quot; &quot;__ne__&quot; &quot;__new__&quot; #&gt; [22] &quot;__reduce__&quot; &quot;__reduce_ex__&quot; &quot;__repr__&quot; #&gt; [25] &quot;__setattr__&quot; &quot;__sizeof__&quot; &quot;__str__&quot; #&gt; [28] &quot;__subclasshook__&quot; &quot;__weakref__&quot; &quot;_check_exists&quot; #&gt; [31] &quot;_format_transform_repr&quot; &quot;_repr_indent&quot; &quot;class_to_idx&quot; #&gt; [34] &quot;classes&quot; &quot;data&quot; &quot;download&quot; #&gt; [37] &quot;extra_repr&quot; &quot;processed_folder&quot; &quot;raw_folder&quot; #&gt; [40] &quot;resources&quot; &quot;root&quot; &quot;target_transform&quot; #&gt; [43] &quot;targets&quot; &quot;test_data&quot; &quot;test_file&quot; #&gt; [46] &quot;test_labels&quot; &quot;train&quot; &quot;train_data&quot; #&gt; [49] &quot;train_labels&quot; &quot;training_file&quot; &quot;transform&quot; #&gt; [52] &quot;transforms&quot; Knowing the internal methods of a class could be useful when we want to refer to a specific property of such class. For example, from the list above, we know that the object train_dataset has an attribute __len__. We can call it like this: train_dataset$`__len__`() #&gt; [1] 60000 3.5 Iterating through datasets 3.5.1 Enumeration Given the following training dataset x_train, we want to find the number of elements of the tensor. We start by entering a numpy array, which then will convert to a tensor with the PyTorch function from_numpy(): x_train_r &lt;- array(c(3.3, 4.4, 5.5, 6.71, 6.93, 4.168, 9.779, 6.182, 7.59, 2.167, 7.042, 10.791, 5.313, 7.997, 3.1), dim = c(15,1)) x_train_np &lt;- r_to_py(x_train_r) x_train_ &lt;- torch$from_numpy(x_train_np) # convert to tensor x_train &lt;- x_train_$type(torch$FloatTensor) # make it a a FloatTensor print(x_train$dtype) print(x_train) #&gt; torch.float32 #&gt; tensor([[ 3.3000], #&gt; [ 4.4000], #&gt; [ 5.5000], #&gt; [ 6.7100], #&gt; [ 6.9300], #&gt; [ 4.1680], #&gt; [ 9.7790], #&gt; [ 6.1820], #&gt; [ 7.5900], #&gt; [ 2.1670], #&gt; [ 7.0420], #&gt; [10.7910], #&gt; [ 5.3130], #&gt; [ 7.9970], #&gt; [ 3.1000]]) length is similar to nelement for number of elements: length(x_train) x_train$nelement() # number of elements in the tensor #&gt; [1] 15 #&gt; [1] 15 3.5.2 enumerate and iterate py = import_builtins() enum_x_train = py$enumerate(x_train) enum_x_train py$len(x_train) #&gt; &lt;enumerate&gt; #&gt; [1] 15 If we directly use iterate over the enum_x_train object, we get an R list with the index and the value of the 1D tensor: xit = iterate(enum_x_train, simplify = TRUE) xit #&gt; [[1]] #&gt; [[1]][[1]] #&gt; [1] 0 #&gt; #&gt; [[1]][[2]] #&gt; tensor([3.3000]) #&gt; #&gt; #&gt; [[2]] #&gt; [[2]][[1]] #&gt; [1] 1 #&gt; #&gt; [[2]][[2]] #&gt; tensor([4.4000]) #&gt; #&gt; #&gt; [[3]] #&gt; [[3]][[1]] #&gt; [1] 2 #&gt; #&gt; [[3]][[2]] #&gt; tensor([5.5000]) #&gt; #&gt; #&gt; [[4]] #&gt; [[4]][[1]] #&gt; [1] 3 #&gt; #&gt; [[4]][[2]] #&gt; tensor([6.7100]) #&gt; #&gt; #&gt; [[5]] #&gt; [[5]][[1]] #&gt; [1] 4 #&gt; #&gt; [[5]][[2]] #&gt; tensor([6.9300]) #&gt; #&gt; #&gt; [[6]] #&gt; [[6]][[1]] #&gt; [1] 5 #&gt; #&gt; [[6]][[2]] #&gt; tensor([4.1680]) #&gt; #&gt; #&gt; [[7]] #&gt; [[7]][[1]] #&gt; [1] 6 #&gt; #&gt; [[7]][[2]] #&gt; tensor([9.7790]) #&gt; #&gt; #&gt; [[8]] #&gt; [[8]][[1]] #&gt; [1] 7 #&gt; #&gt; [[8]][[2]] #&gt; tensor([6.1820]) #&gt; #&gt; #&gt; [[9]] #&gt; [[9]][[1]] #&gt; [1] 8 #&gt; #&gt; [[9]][[2]] #&gt; tensor([7.5900]) #&gt; #&gt; #&gt; [[10]] #&gt; [[10]][[1]] #&gt; [1] 9 #&gt; #&gt; [[10]][[2]] #&gt; tensor([2.1670]) #&gt; #&gt; #&gt; [[11]] #&gt; [[11]][[1]] #&gt; [1] 10 #&gt; #&gt; [[11]][[2]] #&gt; tensor([7.0420]) #&gt; #&gt; #&gt; [[12]] #&gt; [[12]][[1]] #&gt; [1] 11 #&gt; #&gt; [[12]][[2]] #&gt; tensor([10.7910]) #&gt; #&gt; #&gt; [[13]] #&gt; [[13]][[1]] #&gt; [1] 12 #&gt; #&gt; [[13]][[2]] #&gt; tensor([5.3130]) #&gt; #&gt; #&gt; [[14]] #&gt; [[14]][[1]] #&gt; [1] 13 #&gt; #&gt; [[14]][[2]] #&gt; tensor([7.9970]) #&gt; #&gt; #&gt; [[15]] #&gt; [[15]][[1]] #&gt; [1] 14 #&gt; #&gt; [[15]][[2]] #&gt; tensor([3.1000]) 3.5.3 for-loop for iteration Another way of iterating through a dataset that you will see a lot in the PyTorch tutorials is a loop through the length of the dataset. In this case, x_train. We are using cat() for the index (an integer), and print() for the tensor, since cat doesn’t know how to deal with tensors: # reset the iterator enum_x_train = py$enumerate(x_train) for (i in 1:py$len(x_train)) { obj &lt;- iter_next(enum_x_train) # next item cat(obj[[1]], &quot;\\t&quot;) # 1st part or index print(obj[[2]]) # 2nd part or tensor } #&gt; 0 tensor([3.3000]) #&gt; 1 tensor([4.4000]) #&gt; 2 tensor([5.5000]) #&gt; 3 tensor([6.7100]) #&gt; 4 tensor([6.9300]) #&gt; 5 tensor([4.1680]) #&gt; 6 tensor([9.7790]) #&gt; 7 tensor([6.1820]) #&gt; 8 tensor([7.5900]) #&gt; 9 tensor([2.1670]) #&gt; 10 tensor([7.0420]) #&gt; 11 tensor([10.7910]) #&gt; 12 tensor([5.3130]) #&gt; 13 tensor([7.9970]) #&gt; 14 tensor([3.1000]) Similarly, if we want the scalar values but not as tensor, then we will need to use item(). # reset the iterator enum_x_train = py$enumerate(x_train) for (i in 1:py$len(x_train)) { obj &lt;- iter_next(enum_x_train) # next item cat(obj[[1]], &quot;\\t&quot;) # 1st part or index print(obj[[2]]$item()) # 2nd part or tensor } #&gt; 0 [1] 3.3 #&gt; 1 [1] 4.4 #&gt; 2 [1] 5.5 #&gt; 3 [1] 6.71 #&gt; 4 [1] 6.93 #&gt; 5 [1] 4.17 #&gt; 6 [1] 9.78 #&gt; 7 [1] 6.18 #&gt; 8 [1] 7.59 #&gt; 9 [1] 2.17 #&gt; 10 [1] 7.04 #&gt; 11 [1] 10.8 #&gt; 12 [1] 5.31 #&gt; 13 [1] 8 #&gt; 14 [1] 3.1 We will find very frequently this kind of iterators when we read a dataset read by torchvision. There are several different ways to iterate through these objects as you will find. 3.6 Zero gradient The zero gradient was one of the most difficult to implement in R if we don’t pay attention to the content of the objects carrying the weights and biases. This happens when the algorithm written in PyTorch is not immediately translatable to rTorch. This can be appreciated in this example. We are using the same seed in the PyTorch and rTorch versions, so, we could compare the results. 3.6.1 Code version in Python import numpy as np import torch torch.manual_seed(0) # reproducible # Input (temp, rainfall, humidity) #&gt; &lt;torch._C.Generator object at 0x7fe10a7aa3f0&gt; inputs = np.array([[73, 67, 43], [91, 88, 64], [87, 134, 58], [102, 43, 37], [69, 96, 70]], dtype=&#39;float32&#39;) # Targets (apples, oranges) targets = np.array([[56, 70], [81, 101], [119, 133], [22, 37], [103, 119]], dtype=&#39;float32&#39;) # Convert inputs and targets to tensors inputs = torch.from_numpy(inputs) targets = torch.from_numpy(targets) # random weights and biases w = torch.randn(2, 3, requires_grad=True) b = torch.randn(2, requires_grad=True) # function for the model def model(x): wt = w.t() mm = x @ w.t() return x @ w.t() + b # @ represents matrix multiplication in PyTorch # MSE loss function def mse(t1, t2): diff = t1 - t2 return torch.sum(diff * diff) / diff.numel() # Running all together # Train for 100 epochs for i in range(100): preds = model(inputs) loss = mse(preds, targets) loss.backward() with torch.no_grad(): w -= w.grad * 0.00001 b -= b.grad * 0.00001 w_gz = w.grad.zero_() b_gz = b.grad.zero_() # Calculate loss preds = model(inputs) loss = mse(preds, targets) print(&quot;Loss: &quot;, loss) # predictions #&gt; Loss: tensor(1270.1233, grad_fn=&lt;DivBackward0&gt;) print(&quot;\\nPredictions:&quot;) #&gt; #&gt; Predictions: preds # Targets #&gt; tensor([[ 69.3122, 80.2639], #&gt; [ 73.7528, 97.2381], #&gt; [118.3933, 124.7628], #&gt; [ 89.6111, 93.0286], #&gt; [ 47.3014, 80.6467]], grad_fn=&lt;AddBackward0&gt;) print(&quot;\\nTargets:&quot;) #&gt; #&gt; Targets: targets #&gt; tensor([[ 56., 70.], #&gt; [ 81., 101.], #&gt; [119., 133.], #&gt; [ 22., 37.], #&gt; [103., 119.]]) 3.6.2 Code version in R library(rTorch) torch$manual_seed(0) device = torch$device(&#39;cpu&#39;) # Input (temp, rainfall, humidity) inputs = np$array(list(list(73, 67, 43), list(91, 88, 64), list(87, 134, 58), list(102, 43, 37), list(69, 96, 70)), dtype=&#39;float32&#39;) # Targets (apples, oranges) targets = np$array(list(list(56, 70), list(81, 101), list(119, 133), list(22, 37), list(103, 119)), dtype=&#39;float32&#39;) # Convert inputs and targets to tensors inputs = torch$from_numpy(inputs) targets = torch$from_numpy(targets) # random numbers for weights and biases. Then convert to double() torch$set_default_dtype(torch$float64) w = torch$randn(2L, 3L, requires_grad=TRUE) #$double() b = torch$randn(2L, requires_grad=TRUE) #$double() model &lt;- function(x) { wt &lt;- w$t() return(torch$add(torch$mm(x, wt), b)) } # MSE loss mse = function(t1, t2) { diff &lt;- torch$sub(t1, t2) mul &lt;- torch$sum(torch$mul(diff, diff)) return(torch$div(mul, diff$numel())) } # Running all together # Adjust weights and reset gradients for (i in 1:100) { preds = model(inputs) loss = mse(preds, targets) loss$backward() with(torch$no_grad(), { w$data &lt;- torch$sub(w$data, torch$mul(w$grad, torch$scalar_tensor(1e-5))) b$data &lt;- torch$sub(b$data, torch$mul(b$grad, torch$scalar_tensor(1e-5))) w$grad$zero_() b$grad$zero_() }) } # Calculate loss preds = model(inputs) loss = mse(preds, targets) cat(&quot;Loss: &quot;); print(loss) # predictions cat(&quot;\\nPredictions:\\n&quot;) preds # Targets cat(&quot;\\nTargets:\\n&quot;) targets #&gt; &lt;torch._C.Generator&gt; #&gt; Loss: tensor(1270.1237, grad_fn=&lt;DivBackward0&gt;) #&gt; #&gt; Predictions: #&gt; tensor([[ 69.3122, 80.2639], #&gt; [ 73.7528, 97.2381], #&gt; [118.3933, 124.7628], #&gt; [ 89.6111, 93.0286], #&gt; [ 47.3013, 80.6467]], grad_fn=&lt;AddBackward0&gt;) #&gt; #&gt; Targets: #&gt; tensor([[ 56., 70.], #&gt; [ 81., 101.], #&gt; [119., 133.], #&gt; [ 22., 37.], #&gt; [103., 119.]]) Notice that while we are in Python, the tensor operation, gradient (\\(\\nabla\\)) of the weights \\(w\\) times the Learning Rate \\(\\alpha\\), is: \\[w = -w + \\nabla w \\; \\alpha\\] In Python, it is a very straight forwward and clean code: w -= w.grad * 1e-5 In R, without generics, it shows a little bit more convoluted: w$data &lt;- torch$sub(w$data, torch$mul(w$grad, torch$scalar_tensor(1e-5))) 3.7 R generic functions Which why we simplified these common operations using the R generic function. When we use the generic methods from rTorch the operation looks much neater. w$data &lt;- w$data - w$grad * 1e-5 The following two expressions are equivalent, with the first being the long version natural way of doing it in PyTorch. The second is using the generics in R for subtraction, multiplication and scalar conversion. param$data &lt;- torch$sub(param$data, torch$mul(param$grad$float(), torch$scalar_tensor(learning_rate))) } param$data &lt;- param$data - param$grad * learning_rate "],["converting-tensors.html", "Chapter 4 Converting tensors 4.1 Tensor to numpy array 4.2 numpy array to tensor 4.3 R objects to numpy objects", " Chapter 4 Converting tensors Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) library(rTorch) 4.1 Tensor to numpy array This is a frequent operation. I have found that this is necessary when: a numpy function is not implemented in PyTorch We need to convert a tensor to R Perform a boolean operation that is not directly available in PyTorch 4.2 numpy array to tensor Explain how transform a tensor back and forth to numpy. Why is this important? In what cases in this necessary? 4.2.1 numpy array to R This is mainly required for these reasons: Create a data structure in R Plot using r-base or ggplot2 Perform an analysis on parts of a tensor Use R statistical functions that are not available in PyTorch 4.3 R objects to numpy objects TODO "],["tensors.html", "Chapter 5 Tensors 5.1 Tensor data types 5.2 Arithmetic of tensors 5.3 NumPy and PyTorch 5.4 Create tensors 5.5 Tensor resizing 5.6 Concatenate tensors 5.7 Reshape tensors 5.8 Special tensors 5.9 Access to tensor elements 5.10 Other tensor operations 5.11 Logical operations 5.12 Distributions", " Chapter 5 Tensors Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) We describe the most important PyTorch methods in this chapter. library(rTorch) 5.1 Tensor data types # Default data type torch$tensor(list(1.2, 3))$dtype # default for floating point is torch.float32 #&gt; torch.float32 # change default data type to float64 torch$set_default_dtype(torch$float64) torch$tensor(list(1.2, 3))$dtype # a new floating point tensor #&gt; torch.float64 5.1.1 Major tensor types There are five major type of tensors in PyTorch: library(rTorch) byte &lt;- torch$ByteTensor(3L, 3L) float &lt;- torch$FloatTensor(3L, 3L) double &lt;- torch$DoubleTensor(3L, 3L) long &lt;- torch$LongTensor(3L, 3L) boolean &lt;- torch$BoolTensor(5L, 5L) message(&quot;byte tensor&quot;) #&gt; byte tensor byte #&gt; tensor([[ 32, 93, 170], #&gt; [245, 134, 127], #&gt; [ 0, 0, 32]], dtype=torch.uint8) message(&quot;float tensor&quot;) #&gt; float tensor float #&gt; tensor([[0., 0., 0.], #&gt; [0., 0., 0.], #&gt; [0., 0., 0.]], dtype=torch.float32) message(&quot;double&quot;) #&gt; double double #&gt; tensor([[4.9407e-324, 4.6568e-310, 0.0000e+00], #&gt; [ 0.0000e+00, 0.0000e+00, 0.0000e+00], #&gt; [ 0.0000e+00, 0.0000e+00, 0.0000e+00]]) message(&quot;long&quot;) #&gt; long long #&gt; tensor([[ 0, 0, 193273528365], #&gt; [94254217311696, 1, 94254216365136], #&gt; [ 0, 0, 0]]) message(&quot;boolean&quot;) #&gt; boolean boolean #&gt; tensor([[False, False, False, False, False], #&gt; [False, False, False, False, False], #&gt; [False, False, False, False, False], #&gt; [False, False, False, False, False], #&gt; [False, False, False, False, False]]) 5.1.2 Example: A 4D tensor A 4D tensor like in MNIST hand-written digits recognition dataset: mnist_4d &lt;- torch$FloatTensor(60000L, 3L, 28L, 28L) message(&quot;size&quot;) #&gt; size mnist_4d$size() #&gt; torch.Size([60000, 3, 28, 28]) message(&quot;length&quot;) #&gt; length length(mnist_4d) #&gt; [1] 141120000 message(&quot;shape, like in numpy&quot;) #&gt; shape, like in numpy mnist_4d$shape #&gt; torch.Size([60000, 3, 28, 28]) message(&quot;number of elements&quot;) #&gt; number of elements mnist_4d$numel() #&gt; [1] 141120000 5.1.3 Example: A 3D tensor Given a 3D tensor: ft3d &lt;- torch$FloatTensor(4L, 3L, 2L) ft3d #&gt; tensor([[[1.4013e-45, 2.8026e-45], #&gt; [4.2039e-45, 5.6052e-45], #&gt; [7.0065e-45, 8.4078e-45]], #&gt; #&gt; [[9.8091e-45, 1.1210e-44], #&gt; [1.2612e-44, 1.4013e-44], #&gt; [1.5414e-44, 1.6816e-44]], #&gt; #&gt; [[1.8217e-44, 1.9618e-44], #&gt; [2.1019e-44, 2.2421e-44], #&gt; [2.3822e-44, 2.5223e-44]], #&gt; #&gt; [[2.6625e-44, 2.8026e-44], #&gt; [2.9427e-44, 3.0829e-44], #&gt; [3.2230e-44, 3.3631e-44]]], dtype=torch.float32) ft3d$size() #&gt; torch.Size([4, 3, 2]) length(ft3d) #&gt; [1] 24 ft3d$shape #&gt; torch.Size([4, 3, 2]) ft3d$numel #&gt; &lt;built-in method numel of Tensor&gt; 5.2 Arithmetic of tensors 5.2.1 Add tensors # add a scalar to a tensor # 3x5 matrix uniformly distributed between 0 and 1 mat0 &lt;- torch$FloatTensor(3L, 5L)$uniform_(0L, 1L) mat0 + 0.1 #&gt; tensor([[0.7463, 0.5465, 0.8838, 0.3115, 0.5893], #&gt; [0.1959, 0.2747, 0.7737, 0.1435, 0.3121], #&gt; [0.8560, 0.5372, 0.6493, 0.9131, 0.7930]], dtype=torch.float32) 5.2.2 Add tensor elements # fill a 3x5 matrix with 0.1 mat1 &lt;- torch$FloatTensor(3L, 5L)$uniform_(0.1, 0.1) print(mat1) #&gt; tensor([[0.1000, 0.1000, 0.1000, 0.1000, 0.1000], #&gt; [0.1000, 0.1000, 0.1000, 0.1000, 0.1000], #&gt; [0.1000, 0.1000, 0.1000, 0.1000, 0.1000]], dtype=torch.float32) # a vector with all ones mat2 &lt;- torch$FloatTensor(5L)$uniform_(1, 1) print(mat2) #&gt; tensor([1., 1., 1., 1., 1.], dtype=torch.float32) # add element (1,1) to another tensor mat1[1, 1] + mat2 #&gt; tensor([1.1000, 1.1000, 1.1000, 1.1000, 1.1000], dtype=torch.float32) Add two tensors using the function add(): # PyTorch add two tensors x = torch$rand(5L, 4L) y = torch$rand(5L, 4L) print(x$add(y)) #&gt; tensor([[0.7789, 1.5818, 0.0753, 1.7437], #&gt; [1.1092, 1.0394, 0.4624, 0.7183], #&gt; [1.5176, 1.3169, 1.2168, 0.9964], #&gt; [0.8173, 0.5756, 1.0711, 1.4780], #&gt; [1.7176, 1.0442, 1.2863, 1.3486]]) Add two tensors using the generic +: print(x + y) #&gt; tensor([[0.7789, 1.5818, 0.0753, 1.7437], #&gt; [1.1092, 1.0394, 0.4624, 0.7183], #&gt; [1.5176, 1.3169, 1.2168, 0.9964], #&gt; [0.8173, 0.5756, 1.0711, 1.4780], #&gt; [1.7176, 1.0442, 1.2863, 1.3486]]) 5.2.3 Multiply a tensor by a scalar # Multiply tensor by scalar tensor = torch$ones(4L, dtype=torch$float64) scalar = np$float64(4.321) print(scalar) print(torch$scalar_tensor(scalar)) #&gt; [1] 4.32 #&gt; tensor(4.3210) Multiply two tensors using the function mul: (prod = torch$mul(tensor, torch$scalar_tensor(scalar))) #&gt; tensor([4.3210, 4.3210, 4.3210, 4.3210]) Short version using generics (prod = tensor * scalar) #&gt; tensor([4.3210, 4.3210, 4.3210, 4.3210]) 5.3 NumPy and PyTorch numpy has been made available as a module in rTorch. We can call functions from numpy refrerring to it as np$_a_function. Examples: # a 2D numpy array syn0 &lt;- np$random$rand(3L, 5L) print(syn0) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 0.328 0.234 0.3167 0.782 0.564 #&gt; [2,] 0.808 0.433 0.2333 0.253 0.870 #&gt; [3,] 0.756 0.560 0.0905 0.287 0.186 # numpy arrays of zeros syn1 &lt;- np$zeros(c(5L, 10L)) print(syn1) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 0 0 0 0 0 0 0 0 0 0 #&gt; [2,] 0 0 0 0 0 0 0 0 0 0 #&gt; [3,] 0 0 0 0 0 0 0 0 0 0 #&gt; [4,] 0 0 0 0 0 0 0 0 0 0 #&gt; [5,] 0 0 0 0 0 0 0 0 0 0 # add a scalar to a numpy array syn1 = syn1 + 0.1 print(syn1) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 #&gt; [2,] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 #&gt; [3,] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 #&gt; [4,] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 #&gt; [5,] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 And the dot product of both: np$dot(syn0, syn1) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 0.222 0.222 0.222 0.222 0.222 0.222 0.222 0.222 0.222 0.222 #&gt; [2,] 0.260 0.260 0.260 0.260 0.260 0.260 0.260 0.260 0.260 0.260 #&gt; [3,] 0.188 0.188 0.188 0.188 0.188 0.188 0.188 0.188 0.188 0.188 5.3.1 Python Tuples and R vectors In numpy a multidimensional array needs to be defined with a tuple. in R we do it with a vector. In Python, we use a tuple, (5, 5) to indicate the shape of the array: import numpy as np print(np.ones((5, 5))) #&gt; [[1. 1. 1. 1. 1.] #&gt; [1. 1. 1. 1. 1.] #&gt; [1. 1. 1. 1. 1.] #&gt; [1. 1. 1. 1. 1.] #&gt; [1. 1. 1. 1. 1.]] In R, we use a vector c(5L, 5L). The L indicates an integer. l1 &lt;- np$ones(c(5L, 5L)) print(l1) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 1 1 1 1 #&gt; [2,] 1 1 1 1 1 #&gt; [3,] 1 1 1 1 1 #&gt; [4,] 1 1 1 1 1 #&gt; [5,] 1 1 1 1 1 5.3.2 A numpy array from R vectors X &lt;- np$array(rbind(c(1,2,3), c(4,5,6), c(7,8,9))) print(X) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 And we could transpose the array using numpy as well: np$transpose(X) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 5.3.3 numpy arrays to tensors a = np$array(list(1, 2, 3)) # a numpy array t = torch$as_tensor(a) # convert it to tensor print(t) #&gt; tensor([1., 2., 3.]) 5.3.4 Create and fill a tensor We can create the tensor directly from R using tensor(): torch$tensor(list( 1, 2, 3)) # create a tensor t[1L]$fill_(-1) # fill element with -1 print(a) #&gt; tensor([1., 2., 3.]) #&gt; tensor(-1.) #&gt; [1] -1 2 3 5.3.5 Tensor to array, and viceversa This is a very common operation in machine learning: # convert tensor to a numpy array a = torch$rand(5L, 4L) b = a$numpy() print(b) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 0.463 0.636 0.178 0.225 #&gt; [2,] 0.897 0.729 0.921 0.607 #&gt; [3,] 0.423 0.623 0.951 0.602 #&gt; [4,] 0.290 0.597 0.648 0.549 #&gt; [5,] 0.648 0.557 0.154 0.899 # convert a numpy array to a tensor np_a = np$array(c(c(3, 4), c(3, 6))) t_a = torch$from_numpy(np_a) print(t_a) #&gt; tensor([3., 4., 3., 6.]) 5.4 Create tensors A random 1D tensor: ft1 &lt;- torch$FloatTensor(np$random$rand(5L)) print(ft1) #&gt; tensor([0.6396, 0.7005, 0.9702, 0.0600, 0.2777], dtype=torch.float32) Force a tensor as a float of 64-bits: ft2 &lt;- torch$as_tensor(np$random$rand(5L), dtype= torch$float64) print(ft2) #&gt; tensor([0.8829, 0.7054, 0.0037, 0.1531, 0.7040]) Convert the tensor to a float of 16-bits: ft2_dbl &lt;- torch$as_tensor(ft2, dtype = torch$float16) ft2_dbl #&gt; tensor([0.8828, 0.7056, 0.0037, 0.1531, 0.7041], dtype=torch.float16) Create a tensor of size (5 x 7) with uninitialized memory: a &lt;- torch$FloatTensor(5L, 7L) print(a) #&gt; tensor([[0., 0., 0., 0., 0., 0., 0.], #&gt; [0., 0., 0., 0., 0., 0., 0.], #&gt; [0., 0., 0., 0., 0., 0., 0.], #&gt; [0., 0., 0., 0., 0., 0., 0.], #&gt; [0., 0., 0., 0., 0., 0., 0.]], dtype=torch.float32) Using arange to create a tensor. arange starts at 0. v = torch$arange(9L) print(v) #&gt; tensor([0, 1, 2, 3, 4, 5, 6, 7, 8]) # reshape (v = v$view(3L, 3L)) #&gt; tensor([[0, 1, 2], #&gt; [3, 4, 5], #&gt; [6, 7, 8]]) 5.4.1 Tensor fill On this tensor: (v = torch$ones(3L, 3L)) #&gt; tensor([[1., 1., 1.], #&gt; [1., 1., 1.], #&gt; [1., 1., 1.]]) Fill row 1 with 2s: invisible(v[1L, ]$fill_(2L)) print(v) #&gt; tensor([[2., 2., 2.], #&gt; [1., 1., 1.], #&gt; [1., 1., 1.]]) Fill row 2 with 3s: invisible(v[2L, ]$fill_(3L)) print(v) #&gt; tensor([[2., 2., 2.], #&gt; [3., 3., 3.], #&gt; [1., 1., 1.]]) Fill column 3 with fours (4): invisible(v[, 3]$fill_(4L)) print(v) #&gt; tensor([[2., 2., 4.], #&gt; [3., 3., 4.], #&gt; [1., 1., 4.]]) 5.4.2 Tensor with a range of values # Initialize Tensor with a range of value v = torch$arange(10L) # similar to range(5) but creating a Tensor (v = torch$arange(0L, 10L, step = 1L)) # Size 5. Similar to range(0, 5, 1) #&gt; tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 5.4.3 Linear or log scale Tensor Create a tensor with 10 linear points for (1, 10) inclusive: (v = torch$linspace(1L, 10L, steps = 10L)) #&gt; tensor([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) Create a tensor with 10 logarithmic points for (1, 10) inclusive: (v = torch$logspace(start=-10L, end = 10L, steps = 5L)) #&gt; tensor([1.0000e-10, 1.0000e-05, 1.0000e+00, 1.0000e+05, 1.0000e+10]) 5.4.4 In-place / Out-of-place fill On this uninitialized tensor: (a &lt;- torch$FloatTensor(5L, 7L)) #&gt; tensor([[0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, #&gt; 6.0896e+01], #&gt; [3.0751e-41, 0.0000e+00, 0.0000e+00, 6.9425e-02, 3.0751e-41, 0.0000e+00, #&gt; 0.0000e+00], #&gt; [1.4013e-45, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00, #&gt; 0.0000e+00], #&gt; [0.0000e+00, 6.0896e+01, 3.0751e-41, 0.0000e+00, 0.0000e+00, 3.0726e+03, #&gt; 3.0751e-41], #&gt; [0.0000e+00, 0.0000e+00, 1.4013e-45, 0.0000e+00, 0.0000e+00, 0.0000e+00, #&gt; 0.0000e+00]], dtype=torch.float32) Fill the tensor with the value 3.5: a$fill_(3.5) #&gt; tensor([[3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000], #&gt; [3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000], #&gt; [3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000], #&gt; [3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000], #&gt; [3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000]], #&gt; dtype=torch.float32) Add a scalar to the tensor: b &lt;- a$add(4.0) The tensor a is still filled with 3.5. A new tensor b is returned with values 3.5 + 4.0 = 7.5 print(a) print(b) #&gt; tensor([[3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000], #&gt; [3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000], #&gt; [3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000], #&gt; [3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000], #&gt; [3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000, 3.5000]], #&gt; dtype=torch.float32) #&gt; tensor([[7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000], #&gt; [7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000], #&gt; [7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000], #&gt; [7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000], #&gt; [7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000, 7.5000]], #&gt; dtype=torch.float32) 5.5 Tensor resizing x = torch$randn(2L, 3L) # Size 2x3 print(x) #&gt; tensor([[-0.8358, 1.8728, 1.3130], #&gt; [ 1.1024, 0.1082, 0.0225]]) y = x$view(6L) # Resize x to size 6 print(y) #&gt; tensor([-0.8358, 1.8728, 1.3130, 1.1024, 0.1082, 0.0225]) z = x$view(-1L, 2L) # Size 3x2 print(z) #&gt; tensor([[-0.8358, 1.8728], #&gt; [ 1.3130, 1.1024], #&gt; [ 0.1082, 0.0225]]) print(z$shape) #&gt; torch.Size([3, 2]) 5.5.1 Exercise Reproduce this tensor: 0 1 2 3 4 5 6 7 8 # create a vector with the number of elements v = torch$arange(9L) # resize to a 3x3 tensor (v = v$view(3L, 3L)) #&gt; tensor([[0, 1, 2], #&gt; [3, 4, 5], #&gt; [6, 7, 8]]) 5.6 Concatenate tensors x = torch$randn(2L, 3L) print(x) print(x$shape) #&gt; tensor([[-0.3096, 1.4568, 0.2785], #&gt; [ 0.5260, -1.1088, 1.8642]]) #&gt; torch.Size([2, 3]) 5.6.1 Concatenate by rows (x0 &lt;- torch$cat(list(x, x, x), 0L)) print(x0$shape) #&gt; tensor([[-0.3096, 1.4568, 0.2785], #&gt; [ 0.5260, -1.1088, 1.8642], #&gt; [-0.3096, 1.4568, 0.2785], #&gt; [ 0.5260, -1.1088, 1.8642], #&gt; [-0.3096, 1.4568, 0.2785], #&gt; [ 0.5260, -1.1088, 1.8642]]) #&gt; torch.Size([6, 3]) 5.6.2 Concatenate by columns (x1 &lt;- torch$cat(list(x, x, x), 1L)) print(x1$shape) #&gt; tensor([[-0.3096, 1.4568, 0.2785, -0.3096, 1.4568, 0.2785, -0.3096, 1.4568, #&gt; 0.2785], #&gt; [ 0.5260, -1.1088, 1.8642, 0.5260, -1.1088, 1.8642, 0.5260, -1.1088, #&gt; 1.8642]]) #&gt; torch.Size([2, 9]) 5.7 Reshape tensors 5.7.1 With chunk(): Let’s say this is an image tensor with the 3-channels and 28x28 pixels # ----- Reshape tensors ----- img &lt;- torch$ones(3L, 28L, 28L) # Create the tensor of ones print(img$size()) #&gt; torch.Size([3, 28, 28]) On the first dimension dim = 0L, reshape the tensor: img_chunks &lt;- torch$chunk(img, chunks = 3L, dim = 0L) print(length(img_chunks)) print(class(img_chunks)) #&gt; [1] 3 #&gt; [1] &quot;list&quot; img_chunks is a list of three members. The first chunk member: # 1st chunk member img_chunk &lt;- img_chunks[[1]] print(img_chunk$size()) print(img_chunk$sum()) # if the tensor had all ones, what is the sum? #&gt; torch.Size([1, 28, 28]) #&gt; tensor(784.) The second chunk member: # 2nd chunk member img_chunk &lt;- img_chunks[[2]] print(img_chunk$size()) print(img_chunk$sum()) # if the tensor had all ones, what is the sum? #&gt; torch.Size([1, 28, 28]) #&gt; tensor(784.) # 3rd chunk member img_chunk &lt;- img_chunks[[3]] print(img_chunk$size()) print(img_chunk$sum()) # if the tensor had all ones, what is the sum? #&gt; torch.Size([1, 28, 28]) #&gt; tensor(784.) 5.7.1.1 Exercise Create a tensor of shape 3x28x28 filled with values 0.25 on the first channel The second channel with 0.5 The third chanel with 0.75 Find the sum for ecah separate channel Find the sum of all channels 5.7.2 With index_select(): img &lt;- torch$ones(3L, 28L, 28L) # Create the tensor of ones img$size() #&gt; torch.Size([3, 28, 28]) This is the layer 1: # index_select. get layer 1 indices = torch$tensor(c(0L)) img_layer_1 &lt;- torch$index_select(img, dim = 0L, index = indices) The size of the layer: print(img_layer_1$size()) #&gt; torch.Size([1, 28, 28]) The sum of all elements in that layer: print(img_layer_1$sum()) #&gt; tensor(784.) This is the layer 2: # index_select. get layer 2 indices = torch$tensor(c(1L)) img_layer_2 &lt;- torch$index_select(img, dim = 0L, index = indices) print(img_layer_2$size()) print(img_layer_2$sum()) #&gt; torch.Size([1, 28, 28]) #&gt; tensor(784.) This is the layer 3: # index_select. get layer 3 indices = torch$tensor(c(2L)) img_layer_3 &lt;- torch$index_select(img, dim = 0L, index = indices) print(img_layer_3$size()) print(img_layer_3$sum()) #&gt; torch.Size([1, 28, 28]) #&gt; tensor(784.) 5.8 Special tensors 5.8.1 Identity matrix # identity matrix eye = torch$eye(3L) # Create an identity 3x3 tensor print(eye) #&gt; tensor([[1., 0., 0.], #&gt; [0., 1., 0.], #&gt; [0., 0., 1.]]) # a 5x5 identity or unit matrix torch$eye(5L) #&gt; tensor([[1., 0., 0., 0., 0.], #&gt; [0., 1., 0., 0., 0.], #&gt; [0., 0., 1., 0., 0.], #&gt; [0., 0., 0., 1., 0.], #&gt; [0., 0., 0., 0., 1.]]) 5.8.2 Ones (v = torch$ones(10L)) # A tensor of size 10 containing all ones # reshape (v = torch$ones(2L, 1L, 2L, 1L)) # Size 2x1x2x1, a 4D tensor #&gt; tensor([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]) #&gt; tensor([[[[1.], #&gt; [1.]]], #&gt; #&gt; #&gt; [[[1.], #&gt; [1.]]]]) The matrix of ones is also called `unitary matrix. This is a 4x4 unitary matrix. torch$ones(c(4L, 4L)) #&gt; tensor([[1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.]]) # eye tensor eye = torch$eye(3L) print(eye) # like eye tensor v = torch$ones_like(eye) # A tensor with same shape as eye. Fill it with 1. v #&gt; tensor([[1., 0., 0.], #&gt; [0., 1., 0.], #&gt; [0., 0., 1.]]) #&gt; tensor([[1., 1., 1.], #&gt; [1., 1., 1.], #&gt; [1., 1., 1.]]) 5.8.3 Zeros (z = torch$zeros(10L)) # A tensor of size 10 containing all zeros #&gt; tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) # matrix of zeros torch$zeros(c(4L, 4L)) #&gt; tensor([[0., 0., 0., 0.], #&gt; [0., 0., 0., 0.], #&gt; [0., 0., 0., 0.], #&gt; [0., 0., 0., 0.]]) # a 3D tensor of zeros torch$zeros(c(3L, 4L, 2L)) #&gt; tensor([[[0., 0.], #&gt; [0., 0.], #&gt; [0., 0.], #&gt; [0., 0.]], #&gt; #&gt; [[0., 0.], #&gt; [0., 0.], #&gt; [0., 0.], #&gt; [0., 0.]], #&gt; #&gt; [[0., 0.], #&gt; [0., 0.], #&gt; [0., 0.], #&gt; [0., 0.]]]) 5.8.4 Diagonal operations Given the 1D tensor a &lt;- torch$tensor(c(1L, 2L, 3L)) a #&gt; tensor([1, 2, 3]) 5.8.4.1 Diagonal matrix We want to fill the main diagonal with the vector: torch$diag(a) #&gt; tensor([[1, 0, 0], #&gt; [0, 2, 0], #&gt; [0, 0, 3]]) What about filling the diagonal above the main: torch$diag(a, 1L) #&gt; tensor([[0, 1, 0, 0], #&gt; [0, 0, 2, 0], #&gt; [0, 0, 0, 3], #&gt; [0, 0, 0, 0]]) Or the diagonal below the main: torch$diag(a, -1L) #&gt; tensor([[0, 0, 0, 0], #&gt; [1, 0, 0, 0], #&gt; [0, 2, 0, 0], #&gt; [0, 0, 3, 0]]) 5.9 Access to tensor elements # replace an element at position 0, 0 (new_tensor = torch$Tensor(list(list(1, 2), list(3, 4)))) #&gt; tensor([[1., 2.], #&gt; [3., 4.]]) Print element at position 1,1: print(new_tensor[1L, 1L]) #&gt; tensor(1.) Fill element at position 1,1 with 5: new_tensor[1L, 1L]$fill_(5) #&gt; tensor(5.) Show the modified tensor: print(new_tensor) # tensor([[ 5., 2.],[ 3., 4.]]) #&gt; tensor([[5., 2.], #&gt; [3., 4.]]) Access an element at position 1, 0: print(new_tensor[2L, 1L]) # tensor([ 3.]) print(new_tensor[2L, 1L]$item()) # 3. #&gt; tensor(3.) #&gt; [1] 3 5.9.1 Indices to tensor elements On this tensor: x = torch$randn(3L, 4L) print(x) #&gt; tensor([[-0.5774, -0.0147, 0.0070, -0.2647], #&gt; [-0.3752, -0.1630, -0.2327, -0.5391], #&gt; [-0.2780, 0.5529, 0.8770, -1.7276]]) Select indices, dim=0: indices = torch$tensor(list(0L, 2L)) torch$index_select(x, 0L, indices) #&gt; tensor([[-0.5774, -0.0147, 0.0070, -0.2647], #&gt; [-0.2780, 0.5529, 0.8770, -1.7276]]) Select indices, dim=1: torch$index_select(x, 1L, indices) #&gt; tensor([[-0.5774, 0.0070], #&gt; [-0.3752, -0.2327], #&gt; [-0.2780, 0.8770]]) 5.9.2 Using the take function # Take by indices src = torch$tensor(list(list(4, 3, 5), list(6, 7, 8)) ) print(src) print( torch$take(src, torch$tensor(list(0L, 2L, 5L))) ) #&gt; tensor([[4., 3., 5.], #&gt; [6., 7., 8.]]) #&gt; tensor([4., 5., 8.]) 5.10 Other tensor operations 5.10.1 Cross product m1 = torch$ones(3L, 5L) m2 = torch$ones(3L, 5L) v1 = torch$ones(3L) # Cross product # Size 3x5 (r = torch$cross(m1, m2)) #&gt; tensor([[0., 0., 0., 0., 0.], #&gt; [0., 0., 0., 0., 0.], #&gt; [0., 0., 0., 0., 0.]]) 5.10.2 Dot product # Dot product of 2 tensors # Dot product of 2 tensors p &lt;- torch$Tensor(list(4L, 2L)) q &lt;- torch$Tensor(list(3L, 1L)) (r = torch$dot(p, q)) # 14 #&gt; tensor(14.) (r &lt;- p %.*% q) # 14 #&gt; tensor(14.) 5.11 Logical operations m0 = torch$zeros(3L, 5L) m1 = torch$ones(3L, 5L) m2 = torch$eye(3L, 5L) print(m1 == m0) #&gt; tensor([[False, False, False, False, False], #&gt; [False, False, False, False, False], #&gt; [False, False, False, False, False]]) print(m1 != m1) #&gt; tensor([[False, False, False, False, False], #&gt; [False, False, False, False, False], #&gt; [False, False, False, False, False]]) print(m2 == m2) #&gt; tensor([[True, True, True, True, True], #&gt; [True, True, True, True, True], #&gt; [True, True, True, True, True]]) # AND m1 &amp; m1 #&gt; tensor([[1, 1, 1, 1, 1], #&gt; [1, 1, 1, 1, 1], #&gt; [1, 1, 1, 1, 1]], dtype=torch.uint8) # OR m0 | m2 #&gt; tensor([[1, 0, 0, 0, 0], #&gt; [0, 1, 0, 0, 0], #&gt; [0, 0, 1, 0, 0]], dtype=torch.uint8) # OR m1 | m2 #&gt; tensor([[1, 1, 1, 1, 1], #&gt; [1, 1, 1, 1, 1], #&gt; [1, 1, 1, 1, 1]], dtype=torch.uint8) 5.11.1 Extract a unique logical result With all: # tensor is less than A &lt;- torch$ones(60000L, 1L, 28L, 28L) C &lt;- A * 0.5 # is C &lt; A all(torch$lt(C, A)) #&gt; tensor(1, dtype=torch.uint8) all(C &lt; A) #&gt; tensor(1, dtype=torch.uint8) # is A &lt; C all(A &lt; C) #&gt; tensor(0, dtype=torch.uint8) With function all_boolean: all_boolean &lt;- function(x) { # convert tensor of 1s and 0s to a unique boolean as.logical(torch$all(x)$numpy()) } # is C &lt; A all_boolean(torch$lt(C, A)) #&gt; [1] TRUE all_boolean(C &lt; A) #&gt; [1] TRUE # is A &lt; C all_boolean(A &lt; C) #&gt; [1] FALSE 5.11.2 Greater than (gt) # tensor is greater than A &lt;- torch$ones(60000L, 1L, 28L, 28L) D &lt;- A * 2.0 all(torch$gt(D, A)) #&gt; tensor(1, dtype=torch.uint8) all(torch$gt(A, D)) #&gt; tensor(0, dtype=torch.uint8) 5.11.3 Less than or equal (le) # tensor is less than or equal A1 &lt;- torch$ones(60000L, 1L, 28L, 28L) all(torch$le(A1, A1)) #&gt; tensor(1, dtype=torch.uint8) all(A1 &lt;= A1) #&gt; tensor(1, dtype=torch.uint8) # tensor is greater than or equal A0 &lt;- torch$zeros(60000L, 1L, 28L, 28L) all(torch$ge(A0, A0)) #&gt; tensor(1, dtype=torch.uint8) all(A0 &gt;= A0) #&gt; tensor(1, dtype=torch.uint8) all(A1 &gt;= A0) #&gt; tensor(1, dtype=torch.uint8) all(A1 &lt;= A0) #&gt; tensor(0, dtype=torch.uint8) 5.11.4 Logical NOT (!) all_true &lt;- torch$BoolTensor(list(TRUE, TRUE, TRUE, TRUE)) all_true #&gt; tensor([True, True, True, True]) # logical NOT not_all_true &lt;- !all_true not_all_true #&gt; tensor([False, False, False, False]) diag &lt;- torch$eye(5L) diag #&gt; tensor([[1., 0., 0., 0., 0.], #&gt; [0., 1., 0., 0., 0.], #&gt; [0., 0., 1., 0., 0.], #&gt; [0., 0., 0., 1., 0.], #&gt; [0., 0., 0., 0., 1.]]) # logical NOT not_diag &lt;- !diag # convert to integer not_diag$to(dtype=torch$uint8) #&gt; tensor([[0, 1, 1, 1, 1], #&gt; [1, 0, 1, 1, 1], #&gt; [1, 1, 0, 1, 1], #&gt; [1, 1, 1, 0, 1], #&gt; [1, 1, 1, 1, 0]], dtype=torch.uint8) 5.12 Distributions Initialize a tensor randomized with a normal distribution with mean=0, var=1: n &lt;- torch$randn(3500L) n #&gt; tensor([ 0.9998, -1.7226, 1.7131, ..., 1.0492, -0.6541, -0.8143]) plot(n$numpy()) hist(n$numpy()) a &lt;- torch$randn(8L, 5L, 6L) # print(a) print(a$size()) #&gt; torch.Size([8, 5, 6]) plot(a$flatten()$numpy()) hist(a$flatten()$numpy()) 5.12.1 Uniform matrix library(rTorch) # 3x5 matrix uniformly distributed between 0 and 1 mat0 &lt;- torch$FloatTensor(13L, 15L)$uniform_(0L, 1L) plot(mat0$flatten()$numpy()) hist(mat0$flatten()$numpy()) # fill a 3x5 matrix with 0.1 mat1 &lt;- torch$FloatTensor(30L, 50L)$uniform_(0.1, 0.2) plot(mat1$flatten()$numpy()) hist(mat1$flatten()$numpy()) # a vector with all ones mat2 &lt;- torch$FloatTensor(500L)$uniform_(1, 2) plot(mat2$flatten()$numpy()) hist(mat2$flatten()$numpy()) 5.12.2 Binomial distribution Binomial &lt;- torch$distributions$binomial$Binomial m = Binomial(100, torch$tensor(list(0 , .2, .8, 1))) (x = m$sample()) #&gt; tensor([ 0., 16., 77., 100.]) m = Binomial(torch$tensor(list(list(5.), list(10.))), torch$tensor(list(0.5, 0.8))) (x = m$sample()) #&gt; tensor([[2., 2.], #&gt; [6., 9.]]) binom &lt;- Binomial(100, torch$FloatTensor(5L, 10L)) print(binom) #&gt; Binomial(total_count: torch.Size([5, 10]), probs: torch.Size([5, 10]), logits: torch.Size([5, 10])) print(binom$sample_n(100L)$shape) #&gt; torch.Size([100, 5, 10]) plot(binom$sample_n(100L)$flatten()$numpy()) hist(binom$sample_n(100L)$flatten()$numpy()) 5.12.3 Exponential distribution Exponential &lt;- torch$distributions$exponential$Exponential m = Exponential(torch$tensor(list(1.0))) m #&gt; Exponential(rate: tensor([1.])) m$sample() # Exponential distributed with rate=1 #&gt; tensor([1.7832]) expo &lt;- Exponential(rate=0.25) expo_sample &lt;- expo$sample_n(250L) # generate 250 samples print(expo_sample$shape) #&gt; torch.Size([250]) plot(expo_sample$flatten()$numpy()) hist(expo_sample$flatten()$numpy()) 5.12.4 Weibull distribution Weibull &lt;- torch$distributions$weibull$Weibull m = Weibull(torch$tensor(list(1.0)), torch$tensor(list(1.0))) m$sample() # sample from a Weibull distribution with scale=1, concentration=1 #&gt; tensor([0.5729]) 5.12.4.1 Constant scale # constant scale for (k in 1:10) { wei &lt;- Weibull(scale=100, concentration=k) wei_sample &lt;- wei$sample_n(500L) # plot(wei_sample$flatten()$numpy()) hist(main=paste0(&quot;Scale=100; Concentration=&quot;, k), wei_sample$flatten()$numpy()) } 5.12.4.2 Constant concentration # constant concentration for (s in seq(100, 1000, 100)) { wei &lt;- Weibull(scale=s, concentration=1) wei_sample &lt;- wei$sample_n(500L) # plot(wei_sample$flatten()$numpy()) hist(main=paste0(&quot;Concentration=1; Scale=&quot;, s), wei_sample$flatten()$numpy()) } "],["linearalgebra.html", "Chapter 6 Linear Algebra with Torch 6.1 Scalars 6.2 Vectors 6.3 Matrices 6.4 3D+ tensors 6.5 Transpose of a matrix 6.6 Vectors, special case of a matrix 6.7 Tensor arithmetic 6.8 Add a scalar to a tensor 6.9 Multiplying tensors 6.10 Dot product", " Chapter 6 Linear Algebra with Torch Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) The following are basic operations of Linear Algebra using PyTorch. library(rTorch) 6.1 Scalars torch$scalar_tensor(2.78654) torch$scalar_tensor(0L) torch$scalar_tensor(1L) torch$scalar_tensor(TRUE) torch$scalar_tensor(FALSE) #&gt; tensor(2.7865) #&gt; tensor(0.) #&gt; tensor(1.) #&gt; tensor(1.) #&gt; tensor(0.) 6.2 Vectors v &lt;- c(0, 1, 2, 3, 4, 5) torch$as_tensor(v) #&gt; tensor([0., 1., 2., 3., 4., 5.]) 6.2.1 Vector to matrix # row-vector message(&quot;R matrix&quot;) #&gt; R matrix (mr &lt;- matrix(1:10, nrow=1)) message(&quot;as_tensor&quot;) #&gt; as_tensor torch$as_tensor(mr) message(&quot;shape_of_tensor&quot;) #&gt; shape_of_tensor torch$as_tensor(mr)$shape #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 1 2 3 4 5 6 7 8 9 10 #&gt; tensor([[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], dtype=torch.int32) #&gt; torch.Size([1, 10]) 6.2.2 Matrix to tensor # column-vector message(&quot;R matrix, one column&quot;) #&gt; R matrix, one column (mc &lt;- matrix(1:10, ncol=1)) message(&quot;as_tensor&quot;) #&gt; as_tensor torch$as_tensor(mc) message(&quot;size of tensor&quot;) #&gt; size of tensor torch$as_tensor(mc)$shape #&gt; [,1] #&gt; [1,] 1 #&gt; [2,] 2 #&gt; [3,] 3 #&gt; [4,] 4 #&gt; [5,] 5 #&gt; [6,] 6 #&gt; [7,] 7 #&gt; [8,] 8 #&gt; [9,] 9 #&gt; [10,] 10 #&gt; tensor([[ 1], #&gt; [ 2], #&gt; [ 3], #&gt; [ 4], #&gt; [ 5], #&gt; [ 6], #&gt; [ 7], #&gt; [ 8], #&gt; [ 9], #&gt; [10]], dtype=torch.int32) #&gt; torch.Size([10, 1]) 6.3 Matrices message(&quot;R matrix&quot;) #&gt; R matrix (m1 &lt;- matrix(1:24, nrow = 3, byrow = TRUE)) message(&quot;as_tensor&quot;) #&gt; as_tensor (t1 &lt;- torch$as_tensor(m1)) message(&quot;shape&quot;) #&gt; shape torch$as_tensor(m1)$shape message(&quot;size&quot;) #&gt; size torch$as_tensor(m1)$size() message(&quot;dim&quot;) #&gt; dim dim(torch$as_tensor(m1)) message(&quot;length&quot;) #&gt; length length(torch$as_tensor(m1)) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 1 2 3 4 5 6 7 8 #&gt; [2,] 9 10 11 12 13 14 15 16 #&gt; [3,] 17 18 19 20 21 22 23 24 #&gt; tensor([[ 1, 2, 3, 4, 5, 6, 7, 8], #&gt; [ 9, 10, 11, 12, 13, 14, 15, 16], #&gt; [17, 18, 19, 20, 21, 22, 23, 24]], dtype=torch.int32) #&gt; torch.Size([3, 8]) #&gt; torch.Size([3, 8]) #&gt; [1] 3 8 #&gt; [1] 24 message(&quot;R matrix&quot;) #&gt; R matrix (m2 &lt;- matrix(0:99, ncol = 10)) message(&quot;as_tensor&quot;) #&gt; as_tensor (t2 &lt;- torch$as_tensor(m2)) message(&quot;shape&quot;) #&gt; shape t2$shape message(&quot;dim&quot;) #&gt; dim dim(torch$as_tensor(m2)) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 0 10 20 30 40 50 60 70 80 90 #&gt; [2,] 1 11 21 31 41 51 61 71 81 91 #&gt; [3,] 2 12 22 32 42 52 62 72 82 92 #&gt; [4,] 3 13 23 33 43 53 63 73 83 93 #&gt; [5,] 4 14 24 34 44 54 64 74 84 94 #&gt; [6,] 5 15 25 35 45 55 65 75 85 95 #&gt; [7,] 6 16 26 36 46 56 66 76 86 96 #&gt; [8,] 7 17 27 37 47 57 67 77 87 97 #&gt; [9,] 8 18 28 38 48 58 68 78 88 98 #&gt; [10,] 9 19 29 39 49 59 69 79 89 99 #&gt; tensor([[ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90], #&gt; [ 1, 11, 21, 31, 41, 51, 61, 71, 81, 91], #&gt; [ 2, 12, 22, 32, 42, 52, 62, 72, 82, 92], #&gt; [ 3, 13, 23, 33, 43, 53, 63, 73, 83, 93], #&gt; [ 4, 14, 24, 34, 44, 54, 64, 74, 84, 94], #&gt; [ 5, 15, 25, 35, 45, 55, 65, 75, 85, 95], #&gt; [ 6, 16, 26, 36, 46, 56, 66, 76, 86, 96], #&gt; [ 7, 17, 27, 37, 47, 57, 67, 77, 87, 97], #&gt; [ 8, 18, 28, 38, 48, 58, 68, 78, 88, 98], #&gt; [ 9, 19, 29, 39, 49, 59, 69, 79, 89, 99]], dtype=torch.int32) #&gt; torch.Size([10, 10]) #&gt; [1] 10 10 m1[1, 1] m2[1, 1] #&gt; [1] 1 #&gt; [1] 0 t1[1, 1] t2[1, 1] #&gt; tensor(1, dtype=torch.int32) #&gt; tensor(0, dtype=torch.int32) 6.4 3D+ tensors # RGB color image has three axes (img &lt;- torch$rand(3L, 28L, 28L)) img$shape #&gt; tensor([[[0.5408, 0.2529, 0.9677, ..., 0.3514, 0.2082, 0.2122], #&gt; [0.2851, 0.9103, 0.9046, ..., 0.6100, 0.3128, 0.6114], #&gt; [0.1339, 0.6343, 0.2846, ..., 0.9294, 0.1796, 0.9791], #&gt; ..., #&gt; [0.4419, 0.1099, 0.6384, ..., 0.1528, 0.3311, 0.1018], #&gt; [0.3356, 0.8677, 0.5454, ..., 0.0635, 0.9314, 0.0147], #&gt; [0.8637, 0.6208, 0.3249, ..., 0.1953, 0.6828, 0.7171]], #&gt; #&gt; [[0.0566, 0.2195, 0.7114, ..., 0.1051, 0.7512, 0.4257], #&gt; [0.2333, 0.2767, 0.7739, ..., 0.8626, 0.8203, 0.7652], #&gt; [0.0507, 0.2294, 0.9864, ..., 0.7437, 0.8824, 0.0247], #&gt; ..., #&gt; [0.2628, 0.3260, 0.3908, ..., 0.9986, 0.3658, 0.4246], #&gt; [0.9924, 0.4358, 0.2244, ..., 0.4799, 0.3092, 0.6579], #&gt; [0.4495, 0.8237, 0.0721, ..., 0.0793, 0.8177, 0.9302]], #&gt; #&gt; [[0.8903, 0.3725, 0.4584, ..., 0.0739, 0.8608, 0.9524], #&gt; [0.2948, 0.2114, 0.1423, ..., 0.0100, 0.9730, 0.4799], #&gt; [0.4116, 0.8423, 0.0494, ..., 0.5667, 0.2797, 0.9816], #&gt; ..., #&gt; [0.7476, 0.5688, 0.3025, ..., 0.8036, 0.7068, 0.7465], #&gt; [0.9489, 0.5851, 0.1969, ..., 0.2578, 0.1501, 0.2413], #&gt; [0.9354, 0.6982, 0.0582, ..., 0.7092, 0.7711, 0.7072]]]) #&gt; torch.Size([3, 28, 28]) img[1, 1, 1] img[3, 28, 28] #&gt; tensor(0.5408) #&gt; tensor(0.7072) 6.5 Transpose of a matrix (m3 &lt;- matrix(1:25, ncol = 5)) # transpose message(&quot;transpose&quot;) #&gt; transpose tm3 &lt;- t(m3) tm3 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 6 11 16 21 #&gt; [2,] 2 7 12 17 22 #&gt; [3,] 3 8 13 18 23 #&gt; [4,] 4 9 14 19 24 #&gt; [5,] 5 10 15 20 25 #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 2 3 4 5 #&gt; [2,] 6 7 8 9 10 #&gt; [3,] 11 12 13 14 15 #&gt; [4,] 16 17 18 19 20 #&gt; [5,] 21 22 23 24 25 message(&quot;as_tensor&quot;) #&gt; as_tensor (t3 &lt;- torch$as_tensor(m3)) message(&quot;transpose&quot;) #&gt; transpose tt3 &lt;- t3$transpose(dim0 = 0L, dim1 = 1L) tt3 #&gt; tensor([[ 1, 6, 11, 16, 21], #&gt; [ 2, 7, 12, 17, 22], #&gt; [ 3, 8, 13, 18, 23], #&gt; [ 4, 9, 14, 19, 24], #&gt; [ 5, 10, 15, 20, 25]], dtype=torch.int32) #&gt; tensor([[ 1, 2, 3, 4, 5], #&gt; [ 6, 7, 8, 9, 10], #&gt; [11, 12, 13, 14, 15], #&gt; [16, 17, 18, 19, 20], #&gt; [21, 22, 23, 24, 25]], dtype=torch.int32) tm3 == tt3$numpy() # convert first the tensor to numpy #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] TRUE TRUE TRUE TRUE TRUE #&gt; [2,] TRUE TRUE TRUE TRUE TRUE #&gt; [3,] TRUE TRUE TRUE TRUE TRUE #&gt; [4,] TRUE TRUE TRUE TRUE TRUE #&gt; [5,] TRUE TRUE TRUE TRUE TRUE 6.6 Vectors, special case of a matrix message(&quot;R matrix&quot;) #&gt; R matrix m2 &lt;- matrix(0:99, ncol = 10) message(&quot;as_tensor&quot;) #&gt; as_tensor (t2 &lt;- torch$as_tensor(m2)) # in R message(&quot;select column of matrix&quot;) #&gt; select column of matrix (v1 &lt;- m2[, 1]) message(&quot;select row of matrix&quot;) #&gt; select row of matrix (v2 &lt;- m2[10, ]) #&gt; tensor([[ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90], #&gt; [ 1, 11, 21, 31, 41, 51, 61, 71, 81, 91], #&gt; [ 2, 12, 22, 32, 42, 52, 62, 72, 82, 92], #&gt; [ 3, 13, 23, 33, 43, 53, 63, 73, 83, 93], #&gt; [ 4, 14, 24, 34, 44, 54, 64, 74, 84, 94], #&gt; [ 5, 15, 25, 35, 45, 55, 65, 75, 85, 95], #&gt; [ 6, 16, 26, 36, 46, 56, 66, 76, 86, 96], #&gt; [ 7, 17, 27, 37, 47, 57, 67, 77, 87, 97], #&gt; [ 8, 18, 28, 38, 48, 58, 68, 78, 88, 98], #&gt; [ 9, 19, 29, 39, 49, 59, 69, 79, 89, 99]], dtype=torch.int32) #&gt; [1] 0 1 2 3 4 5 6 7 8 9 #&gt; [1] 9 19 29 39 49 59 69 79 89 99 # PyTorch message() #&gt; t2c &lt;- t2[, 1] t2r &lt;- t2[10, ] t2c t2r #&gt; tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=torch.int32) #&gt; tensor([ 9, 19, 29, 39, 49, 59, 69, 79, 89, 99], dtype=torch.int32) In vectors, the vector and its transpose are equal. tt2r &lt;- t2r$transpose(dim0 = 0L, dim1 = 0L) tt2r #&gt; tensor([ 9, 19, 29, 39, 49, 59, 69, 79, 89, 99], dtype=torch.int32) # a tensor of booleans. is vector equal to its transposed? t2r == tt2r #&gt; tensor([True, True, True, True, True, True, True, True, True, True]) 6.7 Tensor arithmetic message(&quot;x&quot;) #&gt; x (x = torch$ones(5L, 4L)) message(&quot;y&quot;) #&gt; y (y = torch$ones(5L, 4L)) message(&quot;x+y&quot;) #&gt; x+y x + y #&gt; tensor([[1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.]]) #&gt; tensor([[1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.]]) #&gt; tensor([[2., 2., 2., 2.], #&gt; [2., 2., 2., 2.], #&gt; [2., 2., 2., 2.], #&gt; [2., 2., 2., 2.], #&gt; [2., 2., 2., 2.]]) \\[A + B = B + A\\] x + y == y + x #&gt; tensor([[True, True, True, True], #&gt; [True, True, True, True], #&gt; [True, True, True, True], #&gt; [True, True, True, True], #&gt; [True, True, True, True]]) 6.8 Add a scalar to a tensor s &lt;- 0.5 # scalar x + s #&gt; tensor([[1.5000, 1.5000, 1.5000, 1.5000], #&gt; [1.5000, 1.5000, 1.5000, 1.5000], #&gt; [1.5000, 1.5000, 1.5000, 1.5000], #&gt; [1.5000, 1.5000, 1.5000, 1.5000], #&gt; [1.5000, 1.5000, 1.5000, 1.5000]]) # scalar multiplying two tensors s * (x + y) #&gt; tensor([[1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.]]) 6.9 Multiplying tensors \\[A * B = B * A\\] message(&quot;x&quot;) #&gt; x (x = torch$ones(5L, 4L)) message(&quot;y&quot;) #&gt; y (y = torch$ones(5L, 4L)) message(&quot;2x+4y&quot;) #&gt; 2x+4y (z = 2 * x + 4 * y) #&gt; tensor([[1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.]]) #&gt; tensor([[1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.], #&gt; [1., 1., 1., 1.]]) #&gt; tensor([[6., 6., 6., 6.], #&gt; [6., 6., 6., 6.], #&gt; [6., 6., 6., 6.], #&gt; [6., 6., 6., 6.], #&gt; [6., 6., 6., 6.]]) x * y == y * x #&gt; tensor([[True, True, True, True], #&gt; [True, True, True, True], #&gt; [True, True, True, True], #&gt; [True, True, True, True], #&gt; [True, True, True, True]]) 6.10 Dot product \\[dot(a,b)_{i,j,k,a,b,c} = \\sum_m a_{i,j,k,m}b_{a,b,m,c}\\] torch$dot(torch$tensor(c(2, 3)), torch$tensor(c(2, 1))) #&gt; tensor(7.) 6.10.1 2D array using Python import numpy as np a = np.array([[1, 2], [3, 4]]) b = np.array([[1, 2], [3, 4]]) print(a) #&gt; [[1 2] #&gt; [3 4]] print(b) #&gt; [[1 2] #&gt; [3 4]] np.dot(a, b) #&gt; array([[ 7, 10], #&gt; [15, 22]]) 6.10.2 2D array using R a &lt;- np$array(list(list(1, 2), list(3, 4))) a b &lt;- np$array(list(list(1, 2), list(3, 4))) b np$dot(a, b) #&gt; [,1] [,2] #&gt; [1,] 1 2 #&gt; [2,] 3 4 #&gt; [,1] [,2] #&gt; [1,] 1 2 #&gt; [2,] 3 4 #&gt; [,1] [,2] #&gt; [1,] 7 10 #&gt; [2,] 15 22 torch.dot() treats both \\(a\\) and \\(b\\) as 1D vectors (irrespective of their original shape) and computes their inner product. at &lt;- torch$as_tensor(a) bt &lt;- torch$as_tensor(b) # torch$dot(at, bt) &lt;- RuntimeError: dot: Expected 1-D argument self, but got 2-D # at %.*% bt If we perform the same dot product operation in Python, we get the same error: import torch import numpy as np a = np.array([[1, 2], [3, 4]]) a #&gt; array([[1, 2], #&gt; [3, 4]]) b = np.array([[1, 2], [3, 4]]) b #&gt; array([[1, 2], #&gt; [3, 4]]) np.dot(a, b) #&gt; array([[ 7, 10], #&gt; [15, 22]]) at = torch.as_tensor(a) bt = torch.as_tensor(b) at #&gt; tensor([[1, 2], #&gt; [3, 4]]) bt #&gt; tensor([[1, 2], #&gt; [3, 4]]) torch.dot(at, bt) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): RuntimeError: 1D tensors expected, got 2D, 2D tensors at /opt/conda/conda-bld/pytorch_1595629401553/work/aten/src/TH/generic/THTensorEvenMoreMath.cpp:83 #&gt; #&gt; Detailed traceback: #&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; a &lt;- torch$Tensor(list(list(1, 2), list(3, 4))) b &lt;- torch$Tensor(c(c(1, 2), c(3, 4))) c &lt;- torch$Tensor(list(list(11, 12), list(13, 14))) a b torch$dot(a, b) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): RuntimeError: 1D tensors expected, got 2D, 1D tensors at /opt/conda/conda-bld/pytorch_1595629401553/work/aten/src/TH/generic/THTensorEvenMoreMath.cpp:83 # this is another way of performing dot product in PyTorch # a$dot(a) #&gt; tensor([[1., 2.], #&gt; [3., 4.]]) #&gt; tensor([1., 2., 3., 4.]) o1 &lt;- torch$ones(2L, 2L) o2 &lt;- torch$ones(2L, 2L) o1 o2 torch$dot(o1, o2) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): RuntimeError: 1D tensors expected, got 2D, 2D tensors at /opt/conda/conda-bld/pytorch_1595629401553/work/aten/src/TH/generic/THTensorEvenMoreMath.cpp:83 o1$dot(o2) #&gt; Error in py_call_impl(callable, dots$args, dots$keywords): RuntimeError: 1D tensors expected, got 2D, 2D tensors at /opt/conda/conda-bld/pytorch_1595629401553/work/aten/src/TH/generic/THTensorEvenMoreMath.cpp:83 #&gt; tensor([[1., 1.], #&gt; [1., 1.]]) #&gt; tensor([[1., 1.], #&gt; [1., 1.]]) # 1D tensors work fine r = torch$dot(torch$Tensor(list(4L, 2L, 4L)), torch$Tensor(list(3L, 4L, 1L))) r #&gt; tensor(24.) 6.10.3 mm and matmul functions So, if we cannor perform 2D tensor operations with the dot product, how do we manage then? ## mm and matmul seem to address the dot product we are looking for in tensors a = torch$randn(2L, 3L) b = torch$randn(3L, 4L) a$mm(b) a$matmul(b) #&gt; tensor([[-1.3399, -0.4470, -0.2241, 0.1692], #&gt; [-1.9971, -0.1704, -1.0074, 0.0357]]) #&gt; tensor([[-1.3399, -0.4470, -0.2241, 0.1692], #&gt; [-1.9971, -0.1704, -1.0074, 0.0357]]) Here is a good explanation: https://stackoverflow.com/a/44525687/5270873 Let’s now prove the associative property of tensors: \\[(A B)^T = B^T A^T\\] abt &lt;- torch$mm(a, b)$transpose(dim0=0L, dim1=1L) abt #&gt; tensor([[-1.3399, -1.9971], #&gt; [-0.4470, -0.1704], #&gt; [-0.2241, -1.0074], #&gt; [ 0.1692, 0.0357]]) at &lt;- a$transpose(dim0=0L, dim1=1L) bt &lt;- b$transpose(dim0=0L, dim1=1L) btat &lt;- torch$matmul(bt, at) btat #&gt; tensor([[-1.3399, -1.9971], #&gt; [-0.4470, -0.1704], #&gt; [-0.2241, -1.0074], #&gt; [ 0.1692, 0.0357]]) And we could unit test if the results are nearly the same with allclose(): # tolerance torch$allclose(abt, btat, rtol=0.0001) #&gt; [1] TRUE "],["creating-pytorch-classes.html", "Chapter 7 Creating PyTorch classes 7.1 Build a PyTorch model class", " Chapter 7 Creating PyTorch classes Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 7.1 Build a PyTorch model class PyTorch classes cannot not directly be instantiated from R. Yet. We need an intermediate step to create a class. For this, we use reticulate functions like py_run_string() that will read the class implementation in Python code, and then assign it to an R object. 7.1.1 Example 1: One layer NN py_run_string(&quot;import torch&quot;) main = py_run_string( &quot; import torch.nn as nn class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.layer = torch.nn.Linear(1, 1) def forward(self, x): x = self.layer(x) return x &quot;) # build a Linear Rgression model net &lt;- main$Net() The R object net now contains all the object in the PyTorch class Net. 7.1.2 Example 2: Logistic Regression main &lt;- py_run_string( &quot; import torch.nn as nn class LogisticRegressionModel(nn.Module): def __init__(self, input_dim, output_dim): super(LogisticRegressionModel, self).__init__() self.linear = nn.Linear(input_dim, output_dim) def forward(self, x): out = self.linear(x) return out &quot;) # build a Logistic Rgression model LogisticRegressionModel &lt;- main$LogisticRegressionModel The R object LogisticRegressionModel now contains all the objects in the PyTorch class LogisticRegressionModel. "],["example-1-a-classification-problem.html", "Chapter 8 Example 1: A classification problem 8.1 Code in Python", " Chapter 8 Example 1: A classification problem Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 8.1 Code in Python I will combine here R and Python code just to show how easy is integrating R and Python. First thing we have to do is loading the package rTorch. We do that in a chunk: library(rTorch) Then, we proceed to copy the standard Python code but in their own Python chunks. This is a very nice example that I found in the web. It explains the classic challenge of classification. When rTorch is loaded, a number of Python libraries are also loaded, which enable us the immediate use of numpy, torch and matplotlib. # Logistic Regression # https://m-alcu.github.io/blog/2018/02/10/logit-pytorch/ import numpy as np import torch import torch.nn.functional as F from torch.autograd import Variable import matplotlib.pyplot as plt The next thing we do is setting a seed to make the example repeatable, in my machine and yours. np.random.seed(2048) Then we generate some random samples. N = 100 D = 2 X = np.random.randn(N, D) * 2 ctr = int(N/2) # center the first N/2 points at (-2,-2) X[:ctr,:] = X[:ctr,:] - 2 * np.ones((ctr, D)) # center the last N/2 points at (2, 2) X[ctr:,:] = X[ctr:,:] + 2 * np.ones((ctr, D)) # labels: first N/2 are 0, last N/2 are 1 # mark the first half with 0 and the sceond half with 1 T = np.array([0] * ctr + [1] * ctr).reshape(100, 1) And plot the original data for reference. # plot the data. color the dots using T plt.scatter(X[:,0], X[:,1], c=T.reshape(N), s=100, alpha=0.5) plt.xlabel(&#39;X(1)&#39;) plt.ylabel(&#39;X(2)&#39;) What follows is the definition of the model using a neural network and train the model. We set up the model: class Model(torch.nn.Module): def __init__(self): super(Model, self).__init__() self.linear = torch.nn.Linear(2, 1) # 2 in and 1 out def forward(self, x): y_pred = torch.sigmoid(self.linear(x)) return y_pred # Our model model = Model() criterion = torch.nn.BCELoss(reduction=&#39;mean&#39;) optimizer = torch.optim.SGD(model.parameters(), lr=0.01) Train the model: x_data = Variable(torch.Tensor(X)) y_data = Variable(torch.Tensor(T)) # Training loop for epoch in range(1000): # Forward pass: Compute predicted y by passing x to the model y_pred = model(x_data) # Compute and print loss loss = criterion(y_pred, y_data) # print(epoch, loss.data[0]) # Zero gradients, perform a backward pass, and update the weights. optimizer.zero_grad() loss.backward() optimizer.step() w = list(model.parameters()) w0 = w[0].data.numpy() w1 = w[1].data.numpy() Finally, we plot the results, by tracing the line that separates two classes, 0 and 1, which are both colored in the plot. print(&quot;Final gradient descend:&quot;, w) # plot the data and separating line #&gt; Final gradient descend: [Parameter containing: #&gt; tensor([[1.1150, 1.1100]], requires_grad=True), Parameter containing: #&gt; tensor([0.0695], requires_grad=True)] plt.scatter(X[:,0], X[:,1], c=T.reshape(N), s=100, alpha=0.5) x_axis = np.linspace(-6, 6, 100) y_axis = -(w1[0] + x_axis * w0[0][0]) / w0[0][1] line_up, = plt.plot(x_axis, y_axis,&#39;r--&#39;, label=&#39;gradient descent&#39;) plt.legend(handles=[line_up]) plt.xlabel(&#39;X(1)&#39;) plt.ylabel(&#39;X(2)&#39;) plt.show() "],["mnistdigits.html", "Chapter 9 Example 2: MNIST handwritten digits 9.1 Code in R 9.2 Code in Python", " Chapter 9 Example 2: MNIST handwritten digits Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 9.1 Code in R Source: https://github.com/yunjey/pytorch-tutorial/blob/master/tutorials/01-basics/logistic_regression/main.py library(rTorch) nn &lt;- torch$nn transforms &lt;- torchvision$transforms torch$set_default_dtype(torch$float) 9.1.1 Hyperparameters # Hyper-parameters input_size &lt;- 784L num_classes &lt;- 10L num_epochs &lt;- 5L batch_size &lt;- 100L learning_rate &lt;- 0.001 9.1.2 Read datasets # MNIST dataset (images and labels) # IDX format local_folder &lt;- &#39;./datasets/raw_data&#39; train_dataset = torchvision$datasets$MNIST(root=local_folder, train=TRUE, transform=transforms$ToTensor(), download=TRUE) test_dataset = torchvision$datasets$MNIST(root=local_folder, train=FALSE, transform=transforms$ToTensor()) # Data loader (input pipeline). Make the datasets iteratble train_loader = torch$utils$data$DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=TRUE) test_loader = torch$utils$data$DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=FALSE) class(train_loader) length(train_loader) #&gt; [1] &quot;torch.utils.data.dataloader.DataLoader&quot; #&gt; [2] &quot;python.builtin.object&quot; #&gt; [1] 2 9.1.3 Define the model # Logistic regression model model = nn$Linear(input_size, num_classes) # Loss and optimizer # nn.CrossEntropyLoss() computes softmax internally criterion = nn$CrossEntropyLoss() optimizer = torch$optim$SGD(model$parameters(), lr=learning_rate) print(model) #&gt; Linear(in_features=784, out_features=10, bias=True) 9.1.4 Training # Train the model iter_train_loader &lt;- iterate(train_loader) total_step &lt;-length(iter_train_loader) for (epoch in 1:num_epochs) { i &lt;- 0 for (obj in iter_train_loader) { images &lt;- obj[[1]] # tensor torch.Size([64, 3, 28, 28]) labels &lt;- obj[[2]] # tensor torch.Size([64]), labels from 0 to 9 # cat(i, &quot;\\t&quot;); print(images$shape) # Reshape images to (batch_size, input_size) images &lt;- images$reshape(-1L, 28L*28L) # images &lt;- torch$as_tensor(images$reshape(-1L, 28L*28L), dtype=torch$double) # Forward pass outputs &lt;- model(images) loss &lt;- criterion(outputs, labels) # Backward and optimize optimizer$zero_grad() loss$backward() optimizer$step() if ((i+1) %% 100 == 0) { cat(sprintf(&#39;Epoch [%d/%d], Step [%d/%d], Loss: %f \\n&#39;, epoch+1, num_epochs, i+1, total_step, loss$item())) } i &lt;- i + 1 } } #&gt; Epoch [2/5], Step [100/600], Loss: 2.220190 #&gt; Epoch [2/5], Step [200/600], Loss: 2.154732 #&gt; Epoch [2/5], Step [300/600], Loss: 2.039645 #&gt; Epoch [2/5], Step [400/600], Loss: 1.965408 #&gt; Epoch [2/5], Step [500/600], Loss: 1.895036 #&gt; Epoch [2/5], Step [600/600], Loss: 1.845664 #&gt; Epoch [3/5], Step [100/600], Loss: 1.700161 #&gt; Epoch [3/5], Step [200/600], Loss: 1.703207 #&gt; Epoch [3/5], Step [300/600], Loss: 1.627442 #&gt; Epoch [3/5], Step [400/600], Loss: 1.578708 #&gt; Epoch [3/5], Step [500/600], Loss: 1.509729 #&gt; Epoch [3/5], Step [600/600], Loss: 1.529512 #&gt; Epoch [4/5], Step [100/600], Loss: 1.366103 #&gt; Epoch [4/5], Step [200/600], Loss: 1.399742 #&gt; Epoch [4/5], Step [300/600], Loss: 1.362495 #&gt; Epoch [4/5], Step [400/600], Loss: 1.325904 #&gt; Epoch [4/5], Step [500/600], Loss: 1.261572 #&gt; Epoch [4/5], Step [600/600], Loss: 1.324740 #&gt; Epoch [5/5], Step [100/600], Loss: 1.147183 #&gt; Epoch [5/5], Step [200/600], Loss: 1.196320 #&gt; Epoch [5/5], Step [300/600], Loss: 1.185650 #&gt; Epoch [5/5], Step [400/600], Loss: 1.154569 #&gt; Epoch [5/5], Step [500/600], Loss: 1.095949 #&gt; Epoch [5/5], Step [600/600], Loss: 1.184654 #&gt; Epoch [6/5], Step [100/600], Loss: 0.997326 #&gt; Epoch [6/5], Step [200/600], Loss: 1.054679 #&gt; Epoch [6/5], Step [300/600], Loss: 1.062189 #&gt; Epoch [6/5], Step [400/600], Loss: 1.032822 #&gt; Epoch [6/5], Step [500/600], Loss: 0.979105 #&gt; Epoch [6/5], Step [600/600], Loss: 1.083479 9.1.5 Prediction # Adjust weights and reset gradients iter_test_loader &lt;- iterate(test_loader) with(torch$no_grad(), { correct &lt;- 0 total &lt;- 0 for (obj in iter_test_loader) { images &lt;- obj[[1]] # tensor torch.Size([64, 3, 28, 28]) labels &lt;- obj[[2]] # tensor torch.Size([64]), labels from 0 to 9 images = images$reshape(-1L, 28L*28L) # images &lt;- torch$as_tensor(images$reshape(-1L, 28L*28L), dtype=torch$double) outputs = model(images) .predicted = torch$max(outputs$data, 1L) predicted &lt;- .predicted[1L] total = total + labels$size(0L) correct = correct + sum((predicted$numpy() == labels$numpy())) } cat(sprintf(&#39;Accuracy of the model on the 10000 test images: %f %%&#39;, (100 * correct / total))) }) #&gt; Accuracy of the model on the 10000 test images: 82.810000 % 9.1.6 Save the model # Save the model checkpoint torch$save(model$state_dict(), &#39;model.ckpt&#39;) 9.2 Code in Python import torch import torchvision import torch.nn as nn import torchvision.transforms as transforms # Hyper-parameters input_size = 784 num_classes = 10 num_epochs = 5 batch_size = 100 learning_rate = 0.001 # MNIST dataset (images and labels) # IDX format local_folder = &#39;./datasets/raw_data&#39; train_dataset = torchvision.datasets.MNIST(root=local_folder, train=True, transform=transforms.ToTensor(), download=True) test_dataset = torchvision.datasets.MNIST(root=local_folder, train=False, transform=transforms.ToTensor()) # Data loader (input pipeline). Make the datasets iteratble train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True) test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=False) "],["linear-regression.html", "Chapter 10 Linear Regression 10.1 Introduction 10.2 Generate the dataset 10.3 Convert arrays to tensors 10.4 numpy array to tensor 10.5 Creating the network model 10.6 Optimizer and Loss 10.7 Training 10.8 Results", " Chapter 10 Linear Regression Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 10.1 Introduction Source: https://www.guru99.com/pytorch-tutorial.html library(rTorch) nn &lt;- torch$nn Variable &lt;- torch$autograd$Variable invisible(torch$manual_seed(123)) 10.2 Generate the dataset Before you start the training process, you need to know our data. You make a random function to test our model. \\(Y = x3 sin(x)+ 3x+0.8 rand(100)\\) np$random$seed(123L) x = np$random$rand(100L) y = np$sin(x) * np$power(x, 3L) + 3L * x + np$random$rand(100L) * 0.8 plot(x, y) 10.3 Convert arrays to tensors Before you start the training process, you need to convert the numpy array to Variables that supported by Torch and autograd. 10.4 numpy array to tensor Notice that before converting to a Torch tensor, we need first to convert the R numeric vector to a numpy array: # convert numpy array to tensor in shape of input size x &lt;- r_to_py(x) y &lt;- r_to_py(y) x = torch$from_numpy(x$reshape(-1L, 1L))$float() y = torch$from_numpy(y$reshape(-1L, 1L))$float() print(x, y) #&gt; tensor([[0.6965], #&gt; [0.2861], #&gt; [0.2269], #&gt; [0.5513], #&gt; [0.7195], #&gt; [0.4231], #&gt; [0.9808], #&gt; [0.6848], #&gt; [0.4809], #&gt; [0.3921], #&gt; [0.3432], #&gt; [0.7290], #&gt; [0.4386], #&gt; [0.0597], #&gt; [0.3980], #&gt; [0.7380], #&gt; [0.1825], #&gt; [0.1755], #&gt; [0.5316], #&gt; [0.5318], #&gt; [0.6344], #&gt; [0.8494], #&gt; [0.7245], #&gt; [0.6110], #&gt; [0.7224], #&gt; [0.3230], #&gt; [0.3618], #&gt; [0.2283], #&gt; [0.2937], #&gt; [0.6310], #&gt; [0.0921], #&gt; [0.4337], #&gt; [0.4309], #&gt; [0.4937], #&gt; [0.4258], #&gt; [0.3123], #&gt; [0.4264], #&gt; [0.8934], #&gt; [0.9442], #&gt; [0.5018], #&gt; [0.6240], #&gt; [0.1156], #&gt; [0.3173], #&gt; [0.4148], #&gt; [0.8663], #&gt; [0.2505], #&gt; [0.4830], #&gt; [0.9856], #&gt; [0.5195], #&gt; [0.6129], #&gt; [0.1206], #&gt; [0.8263], #&gt; [0.6031], #&gt; [0.5451], #&gt; [0.3428], #&gt; [0.3041], #&gt; [0.4170], #&gt; [0.6813], #&gt; [0.8755], #&gt; [0.5104], #&gt; [0.6693], #&gt; [0.5859], #&gt; [0.6249], #&gt; [0.6747], #&gt; [0.8423], #&gt; [0.0832], #&gt; [0.7637], #&gt; [0.2437], #&gt; [0.1942], #&gt; [0.5725], #&gt; [0.0957], #&gt; [0.8853], #&gt; [0.6272], #&gt; [0.7234], #&gt; [0.0161], #&gt; [0.5944], #&gt; [0.5568], #&gt; [0.1590], #&gt; [0.1531], #&gt; [0.6955], #&gt; [0.3188], #&gt; [0.6920], #&gt; [0.5544], #&gt; [0.3890], #&gt; [0.9251], #&gt; [0.8417], #&gt; [0.3574], #&gt; [0.0436], #&gt; [0.3048], #&gt; [0.3982], #&gt; [0.7050], #&gt; [0.9954], #&gt; [0.3559], #&gt; [0.7625], #&gt; [0.5932], #&gt; [0.6917], #&gt; [0.1511], #&gt; [0.3989], #&gt; [0.2409], #&gt; [0.3435]]) 10.5 Creating the network model Our network model is a simple Linear layer with an input and an output shape of one. And the network output should be like this Net( (hidden): Linear(in_features=1, out_features=1, bias=True) ) py_run_string(&quot;import torch&quot;) main = py_run_string( &quot; import torch.nn as nn class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.layer = torch.nn.Linear(1, 1) def forward(self, x): x = self.layer(x) return x &quot;) # build a Linear Rgression model net &lt;- main$Net() print(net) #&gt; Net( #&gt; (layer): Linear(in_features=1, out_features=1, bias=True) #&gt; ) 10.6 Optimizer and Loss Next, you should define the Optimizer and the Loss Function for our training process. # Define Optimizer and Loss Function optimizer &lt;- torch$optim$SGD(net$parameters(), lr=0.2) loss_func &lt;- torch$nn$MSELoss() print(optimizer) print(loss_func) #&gt; SGD ( #&gt; Parameter Group 0 #&gt; dampening: 0 #&gt; lr: 0.2 #&gt; momentum: 0 #&gt; nesterov: False #&gt; weight_decay: 0 #&gt; ) #&gt; MSELoss() 10.7 Training Now let’s start our training process. With an epoch of 250, you will iterate our data to find the best value for our hyperparameters. # x = x$type(torch$float) # make it a a FloatTensor # y = y$type(torch$float) # x &lt;- torch$as_tensor(x, dtype = torch$float) # y &lt;- torch$as_tensor(y, dtype = torch$float) inputs = Variable(x) outputs = Variable(y) # base plot plot(x$data$numpy(), y$data$numpy(), col = &quot;blue&quot;) for (i in 1:250) { prediction = net(inputs) loss = loss_func(prediction, outputs) optimizer$zero_grad() loss$backward() optimizer$step() if (i &gt; 1) break if (i %% 10 == 0) { # plot and show learning process # points(x$data$numpy(), y$data$numpy()) points(x$data$numpy(), prediction$data$numpy(), col=&quot;red&quot;) # cat(i, loss$data$numpy(), &quot;\\n&quot;) } } 10.8 Results As you can see, you successfully performed regression with a neural network. Actually, on every iteration, the red line in the plot will update and change its position to fit the data. But in this picture, you only show you the final result. "],["linear-regression-1.html", "Chapter 11 Linear Regression 11.1 Rainfall prediction 11.2 Training data 11.3 Convert arrays to tensors 11.4 Build the model 11.5 Generate predictions 11.6 Loss Function 11.7 Step by step process 11.8 All together", " Chapter 11 Linear Regression Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 11.1 Rainfall prediction library(rTorch) Select the device: CPU or GPU invisible(torch$manual_seed(0)) device = torch$device(&#39;cpu&#39;) 11.2 Training data The training data can be represented using 2 matrices (inputs and targets), each with one row per observation, and one column per variable. # Input (temp, rainfall, humidity) inputs = np$array(list(list(73, 67, 43), list(91, 88, 64), list(87, 134, 58), list(102, 43, 37), list(69, 96, 70)), dtype=&#39;float32&#39;) # Targets (apples, oranges) targets = np$array(list(list(56, 70), list(81, 101), list(119, 133), list(22, 37), list(103, 119)), dtype=&#39;float32&#39;) 11.3 Convert arrays to tensors Before we build a model, we need to convert inputs and targets to PyTorch tensors. # Convert inputs and targets to tensors inputs = torch$from_numpy(inputs) targets = torch$from_numpy(targets) print(inputs) print(targets) #&gt; tensor([[ 73., 67., 43.], #&gt; [ 91., 88., 64.], #&gt; [ 87., 134., 58.], #&gt; [102., 43., 37.], #&gt; [ 69., 96., 70.]], dtype=torch.float64) #&gt; tensor([[ 56., 70.], #&gt; [ 81., 101.], #&gt; [119., 133.], #&gt; [ 22., 37.], #&gt; [103., 119.]], dtype=torch.float64) The weights and biases can also be represented as matrices, initialized with random values. The first row of \\(w\\) and the first element of \\(b\\) are used to predict the first target variable, i.e. yield for apples, and, similarly, the second for oranges. # random numbers for weights and biases. Then convert to double() torch$set_default_dtype(torch$double) w = torch$randn(2L, 3L, requires_grad=TRUE) #$double() b = torch$randn(2L, requires_grad=TRUE) #$double() print(w) print(b) #&gt; tensor([[ 1.5410, -0.2934, -2.1788], #&gt; [ 0.5684, -1.0845, -1.3986]], requires_grad=True) #&gt; tensor([0.4033, 0.8380], requires_grad=True) 11.4 Build the model The model is simply a function that performs a matrix multiplication of the input \\(x\\) and the weights \\(w\\) (transposed), and adds the bias \\(b\\) (replicated for each observation). model &lt;- function(x) { wt &lt;- w$t() return(torch$add(torch$mm(x, wt), b)) } 11.5 Generate predictions The matrix obtained by passing the input data to the model is a set of predictions for the target variables. # Generate predictions preds = model(inputs) print(preds) #&gt; tensor([[ -0.4516, -90.4691], #&gt; [ -24.6303, -132.3828], #&gt; [ -31.2192, -176.1530], #&gt; [ 64.3523, -39.5645], #&gt; [ -73.9524, -161.9560]], grad_fn=&lt;AddBackward0&gt;) # Compare with targets print(targets) #&gt; tensor([[ 56., 70.], #&gt; [ 81., 101.], #&gt; [119., 133.], #&gt; [ 22., 37.], #&gt; [103., 119.]]) Because we’ve started with random weights and biases, the model does not a very good job of predicting the target variables. 11.6 Loss Function We can compare the predictions with the actual targets, using the following method: Calculate the difference between the two matrices (preds and targets). Square all elements of the difference matrix to remove negative values. Calculate the average of the elements in the resulting matrix. The result is a single number, known as the mean squared error (MSE). # MSE loss mse = function(t1, t2) { diff &lt;- torch$sub(t1, t2) mul &lt;- torch$sum(torch$mul(diff, diff)) return(torch$div(mul, diff$numel())) } print(mse) #&gt; function(t1, t2) { #&gt; diff &lt;- torch$sub(t1, t2) #&gt; mul &lt;- torch$sum(torch$mul(diff, diff)) #&gt; return(torch$div(mul, diff$numel())) #&gt; } 11.7 Step by step process 11.7.1 Compute the losses # Compute loss loss = mse(preds, targets) print(loss) # 46194 # 33060.8070 #&gt; tensor(33060.8053, grad_fn=&lt;DivBackward0&gt;) The resulting number is called the loss, because it indicates how bad the model is at predicting the target variables. Lower the loss, better the model. 11.7.2 Compute Gradients With PyTorch, we can automatically compute the gradient or derivative of the loss w.r.t. to the weights and biases, because they have requires_grad set to True. # Compute gradients loss$backward() The gradients are stored in the .grad property of the respective tensors. # Gradients for weights print(w) print(w$grad) #&gt; tensor([[ 1.5410, -0.2934, -2.1788], #&gt; [ 0.5684, -1.0845, -1.3986]], requires_grad=True) #&gt; tensor([[ -6938.4351, -9674.6757, -5744.0206], #&gt; [-17408.7861, -20595.9333, -12453.4702]]) # Gradients for bias print(b) print(b$grad) #&gt; tensor([0.4033, 0.8380], requires_grad=True) #&gt; tensor([ -89.3802, -212.1051]) A key insight from calculus is that the gradient indicates the rate of change of the loss, or the slope of the loss function w.r.t. the weights and biases. If a gradient element is positive: increasing the element’s value slightly will increase the loss. decreasing the element’s value slightly will decrease the loss. If a gradient element is negative, increasing the element’s value slightly will decrease the loss. decreasing the element’s value slightly will increase the loss. The increase or decrease is proportional to the value of the gradient. 11.7.3 Reset the gradients Finally, we’ll reset the gradients to zero before moving forward, because PyTorch accumulates gradients. # Reset the gradients w$grad$zero_() b$grad$zero_() print(w$grad) print(b$grad) #&gt; tensor([[0., 0., 0.], #&gt; [0., 0., 0.]]) #&gt; tensor([0., 0.]) #&gt; tensor([[0., 0., 0.], #&gt; [0., 0., 0.]]) #&gt; tensor([0., 0.]) 11.7.3.1 Adjust weights and biases We’ll reduce the loss and improve our model using the gradient descent algorithm, which has the following steps: Generate predictions Calculate the loss Compute gradients w.r.t the weights and biases Adjust the weights by subtracting a small quantity proportional to the gradient Reset the gradients to zero # Generate predictions preds = model(inputs) print(preds) #&gt; tensor([[ -0.4516, -90.4691], #&gt; [ -24.6303, -132.3828], #&gt; [ -31.2192, -176.1530], #&gt; [ 64.3523, -39.5645], #&gt; [ -73.9524, -161.9560]], grad_fn=&lt;AddBackward0&gt;) # Calculate the loss loss = mse(preds, targets) print(loss) #&gt; tensor(33060.8053, grad_fn=&lt;DivBackward0&gt;) # Compute gradients loss$backward() print(w$grad) print(b$grad) #&gt; tensor([[ -6938.4351, -9674.6757, -5744.0206], #&gt; [-17408.7861, -20595.9333, -12453.4702]]) #&gt; tensor([ -89.3802, -212.1051]) # Adjust weights and reset gradients with(torch$no_grad(), { print(w); print(b) # requires_grad attribute remains w$data &lt;- torch$sub(w$data, torch$mul(w$grad$data, torch$scalar_tensor(1e-5))) b$data &lt;- torch$sub(b$data, torch$mul(b$grad$data, torch$scalar_tensor(1e-5))) print(w$grad$data$zero_()) print(b$grad$data$zero_()) }) print(w) print(b) #&gt; tensor([[ 1.5410, -0.2934, -2.1788], #&gt; [ 0.5684, -1.0845, -1.3986]], requires_grad=True) #&gt; tensor([0.4033, 0.8380], requires_grad=True) #&gt; tensor([[0., 0., 0.], #&gt; [0., 0., 0.]]) #&gt; tensor([0., 0.]) #&gt; tensor([[ 1.6104, -0.1967, -2.1213], #&gt; [ 0.7425, -0.8786, -1.2741]], requires_grad=True) #&gt; tensor([0.4042, 0.8401], requires_grad=True) With the new weights and biases, the model should have a lower loss. # Calculate loss preds = model(inputs) loss = mse(preds, targets) print(loss) #&gt; tensor(23432.4894, grad_fn=&lt;DivBackward0&gt;) 11.8 All together ###T Training for multiple epochs To reduce the loss further, we repeat the process of adjusting the weights and biases using the gradients multiple times. Each iteration is called an epoch. # Running all together # Adjust weights and reset gradients num_epochs &lt;- 100 for (i in 1:num_epochs) { preds = model(inputs) loss = mse(preds, targets) loss$backward() with(torch$no_grad(), { w$data &lt;- torch$sub(w$data, torch$mul(w$grad, torch$scalar_tensor(1e-5))) b$data &lt;- torch$sub(b$data, torch$mul(b$grad, torch$scalar_tensor(1e-5))) w$grad$zero_() b$grad$zero_() }) } # Calculate loss preds = model(inputs) loss = mse(preds, targets) print(loss) # predictions preds # Targets targets #&gt; tensor(1258.0216, grad_fn=&lt;DivBackward0&gt;) #&gt; tensor([[ 69.2462, 80.2082], #&gt; [ 73.7183, 97.2052], #&gt; [118.5780, 124.9272], #&gt; [ 89.2282, 92.7052], #&gt; [ 47.4648, 80.7782]], grad_fn=&lt;AddBackward0&gt;) #&gt; tensor([[ 56., 70.], #&gt; [ 81., 101.], #&gt; [119., 133.], #&gt; [ 22., 37.], #&gt; [103., 119.]]) "],["neural-networks.html", "Chapter 12 Neural Networks 12.1 rTorch and PyTorch 12.2 A neural network with numpy 12.3 A neural network with r-base 12.4 A PyTorch neural network 12.5 A neural network in rTorch 12.6 Full Neural Network in rTorch 12.7 Exercise", " Chapter 12 Neural Networks Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 12.1 rTorch and PyTorch We will compare three neural networks: a neural network written in numpy a neural network written in r-base a neural network written in PyTorch a neural network written in rTorch 12.2 A neural network with numpy We start the neural network by simply using numpy: library(rTorch) # A simple neural network using NumPy # Code in file tensor/two_layer_net_numpy.py import time import numpy as np tic = time.process_time() np.random.seed(123) # set a seed for reproducibility # N is batch size; D_in is input dimension; # H is hidden dimension; D_out is output dimension. N, D_in, H, D_out = 64, 1000, 100, 10 # Create random input and output data x = np.random.randn(N, D_in) y = np.random.randn(N, D_out) # print(x.shape) # print(y.shape) w1 = np.random.randn(D_in, H) w2 = np.random.randn(H, D_out) # print(w1.shape) # print(w2.shape) learning_rate = 1e-6 for t in range(500): # Forward pass: compute predicted y h = x.dot(w1) # print(t, h.max()) h_relu = np.maximum(h, 0) y_pred = h_relu.dot(w2) # Compute and print loss sq = np.square(y_pred - y) loss = sq.sum() print(t, loss) # Backprop to compute gradients of w1 and w2 with respect to loss grad_y_pred = 2.0 * (y_pred - y) grad_w2 = h_relu.T.dot(grad_y_pred) grad_h_relu = grad_y_pred.dot(w2.T) grad_h = grad_h_relu.copy() grad_h[h &lt; 0] = 0 grad_w1 = x.T.dot(grad_h) # Update weights w1 -= learning_rate * grad_w1 w2 -= learning_rate * grad_w2 # processing time #&gt; 0 28624200.800938517 #&gt; 1 24402861.381040636 #&gt; 2 23157437.29147552 #&gt; 3 21617191.63397175 #&gt; 4 18598190.361558598 #&gt; 5 14198211.419692844 #&gt; 6 9786244.45261814 #&gt; 7 6233451.217340663 #&gt; 8 3862647.267829599 #&gt; 9 2412366.632764836 #&gt; 10 1569915.4392193707 #&gt; 11 1078501.3381487518 #&gt; 12 785163.9233288621 #&gt; 13 601495.2825043725 #&gt; 14 479906.0403613456 #&gt; 15 394555.19331746205 #&gt; 16 331438.6987273826 #&gt; 17 282679.6687873873 #&gt; 18 243807.84432087594 #&gt; 19 211970.18110708205 #&gt; 20 185451.6861514274 #&gt; 21 163078.20881862927 #&gt; 22 144011.80160918707 #&gt; 23 127662.96132466741 #&gt; 24 113546.29175681781 #&gt; 25 101291.55288493488 #&gt; 26 90623.20833654879 #&gt; 27 81307.32590692889 #&gt; 28 73135.24710426925 #&gt; 29 65937.50294095621 #&gt; 30 59570.26425368039 #&gt; 31 53923.82804264227 #&gt; 32 48909.69273028215 #&gt; 33 44438.89933807681 #&gt; 34 40445.34031569733 #&gt; 35 36873.30041989413 #&gt; 36 33664.990437423825 #&gt; 37 30781.198962949587 #&gt; 38 28184.24227268406 #&gt; 39 25843.99793108194 #&gt; 40 23727.282448406426 #&gt; 41 21810.062067327668 #&gt; 42 20071.326437572196 #&gt; 43 18492.63752543329 #&gt; 44 17056.72779714255 #&gt; 45 15749.299484025236 #&gt; 46 14557.324481207237 #&gt; 47 13468.469764338035 #&gt; 48 12473.575866914027 #&gt; 49 11562.485809665774 #&gt; 50 10727.865926563407 #&gt; 51 9962.411372816146 #&gt; 52 9259.619803682268 #&gt; 53 8613.269071227103 #&gt; 54 8018.523834750763 #&gt; 55 7471.080819104451 #&gt; 56 6966.00651845651 #&gt; 57 6499.96685422581 #&gt; 58 6069.576425345411 #&gt; 59 5671.2821228408475 #&gt; 60 5302.644980086279 #&gt; 61 4961.339043761728 #&gt; 62 4645.02541423451 #&gt; 63 4351.473575805103 #&gt; 64 4079.2165446062972 #&gt; 65 3826.1480820887655 #&gt; 66 3590.887308956795 #&gt; 67 3372.0103280622666 #&gt; 68 3168.173408650748 #&gt; 69 2978.362100081684 #&gt; 70 2801.302649097963 #&gt; 71 2636.037950790892 #&gt; 72 2481.7354010452655 #&gt; 73 2337.6093944873246 #&gt; 74 2202.8250425683987 #&gt; 75 2076.8872560589616 #&gt; 76 1958.9976460120263 #&gt; 77 1848.5060338548483 #&gt; 78 1744.9993380824799 #&gt; 79 1647.9807349258715 #&gt; 80 1556.9947585282196 #&gt; 81 1471.7081797400347 #&gt; 82 1391.6136870762566 #&gt; 83 1316.3329239757227 #&gt; 84 1245.5902641069824 #&gt; 85 1179.0691783286234 #&gt; 86 1116.5095209528572 #&gt; 87 1057.6662051951396 #&gt; 88 1002.2519686823666 #&gt; 89 950.0167505993219 #&gt; 90 900.7916929993518 #&gt; 91 854.3816389576979 #&gt; 92 810.6277767708903 #&gt; 93 769.3592041348505 #&gt; 94 730.3836012940042 #&gt; 95 693.5644048073411 #&gt; 96 658.7807027999521 #&gt; 97 625.9238747325827 #&gt; 98 594.8758111695068 #&gt; 99 565.4973547949257 #&gt; 100 537.7012178149556 #&gt; 101 511.3901106843991 #&gt; 102 486.4837276215478 #&gt; 103 462.90746955458474 #&gt; 104 440.5787622887435 #&gt; 105 419.4121231392399 #&gt; 106 399.34612374957226 #&gt; 107 380.3221777272873 #&gt; 108 362.2821345456067 #&gt; 109 345.18049757120184 #&gt; 110 328.94028615976936 #&gt; 111 313.5191206271147 #&gt; 112 298.8754770672758 #&gt; 113 284.96926791620496 #&gt; 114 271.7642984526849 #&gt; 115 259.2246266311472 #&gt; 116 247.30122156531897 #&gt; 117 235.96203976771662 #&gt; 118 225.17874184522793 #&gt; 119 214.9253969806085 #&gt; 120 205.16916168826197 #&gt; 121 195.88920014324063 #&gt; 122 187.0522150132689 #&gt; 123 178.6428873875804 #&gt; 124 170.63479897325027 #&gt; 125 163.00806018890546 #&gt; 126 155.7440191346056 #&gt; 127 148.83352898111042 #&gt; 128 142.2496666996878 #&gt; 129 135.97509122834504 #&gt; 130 129.98982612428355 #&gt; 131 124.28418865778005 #&gt; 132 118.84482149781273 #&gt; 133 113.65645952102406 #&gt; 134 108.7054397008061 #&gt; 135 103.98144604072209 #&gt; 136 99.47512083365962 #&gt; 137 95.17318303450762 #&gt; 138 91.06775169947714 #&gt; 139 87.14952592945869 #&gt; 140 83.4075554849774 #&gt; 141 79.8333553283839 #&gt; 142 76.41993249926654 #&gt; 143 73.159531678603 #&gt; 144 70.04535899921396 #&gt; 145 67.0700037713867 #&gt; 146 64.22536514818646 #&gt; 147 61.50715956099643 #&gt; 148 58.90970110703718 #&gt; 149 56.42818157298958 #&gt; 150 54.053456343974474 #&gt; 151 51.78409899250521 #&gt; 152 49.613042222061935 #&gt; 153 47.537088681832714 #&gt; 154 45.55073951374691 #&gt; 155 43.651385230775375 #&gt; 156 41.8333828820336 #&gt; 157 40.0944925576898 #&gt; 158 38.4304655768987 #&gt; 159 36.83773398481151 #&gt; 160 35.313368600585044 #&gt; 161 33.85436928433868 #&gt; 162 32.457997092726586 #&gt; 163 31.120973836567913 #&gt; 164 29.841057186484246 #&gt; 165 28.61536631365921 #&gt; 166 27.441646501921213 #&gt; 167 26.31767712811449 #&gt; 168 25.241065734351473 #&gt; 169 24.210568668753154 #&gt; 170 23.223366825888164 #&gt; 171 22.27691447596546 #&gt; 172 21.370561777029383 #&gt; 173 20.502013041055037 #&gt; 174 19.669605151002397 #&gt; 175 18.872156637147214 #&gt; 176 18.107932697664136 #&gt; 177 17.375347093063624 #&gt; 178 16.67329705241241 #&gt; 179 16.000313127916616 #&gt; 180 15.355056259809643 #&gt; 181 14.736642044314163 #&gt; 182 14.143657665391123 #&gt; 183 13.575482981169435 #&gt; 184 13.03055792072713 #&gt; 185 12.507813624903267 #&gt; 186 12.00650847964371 #&gt; 187 11.525873890625666 #&gt; 188 11.064924569594556 #&gt; 189 10.622845128602144 #&gt; 190 10.199224278747348 #&gt; 191 9.79248532294249 #&gt; 192 9.40221537769526 #&gt; 193 9.027996925837858 #&gt; 194 8.668895520243254 #&gt; 195 8.324385761675554 #&gt; 196 7.99390867066041 #&gt; 197 7.676665609325665 #&gt; 198 7.3722991001285685 #&gt; 199 7.080233920966563 #&gt; 200 6.7999405980009 #&gt; 201 6.530984430178585 #&gt; 202 6.2728878687947365 #&gt; 203 6.025197539285438 #&gt; 204 5.787473375780924 #&gt; 205 5.559253501791474 #&gt; 206 5.340172472449113 #&gt; 207 5.129896948041436 #&gt; 208 4.928007606815918 #&gt; 209 4.734225282679221 #&gt; 210 4.548186858907342 #&gt; 211 4.369651328446663 #&gt; 212 4.198236457646962 #&gt; 213 4.033565011138579 #&gt; 214 3.8754625080281464 #&gt; 215 3.7236914115521316 #&gt; 216 3.5779627242857224 #&gt; 217 3.4379821914239286 #&gt; 218 3.303565587540205 #&gt; 219 3.174454405800678 #&gt; 220 3.0504743070396323 #&gt; 221 2.931383709316906 #&gt; 222 2.8170418304762785 #&gt; 223 2.7072412196038553 #&gt; 224 2.6017277000868093 #&gt; 225 2.50040409121904 #&gt; 226 2.403078781570677 #&gt; 227 2.309594481835507 #&gt; 228 2.219794799730801 #&gt; 229 2.133526678637347 #&gt; 230 2.0506760423604566 #&gt; 231 1.9710453639295484 #&gt; 232 1.894559024310974 #&gt; 233 1.8211210547720629 #&gt; 234 1.7505340383436803 #&gt; 235 1.6826932948721067 #&gt; 236 1.6175070289508109 #&gt; 237 1.5549072300348752 #&gt; 238 1.4947316986695944 #&gt; 239 1.436912502600996 #&gt; 240 1.381372987946563 #&gt; 241 1.3279854205041584 #&gt; 242 1.2766884038688984 #&gt; 243 1.2273848146334094 #&gt; 244 1.1800217450316255 #&gt; 245 1.1344919105891025 #&gt; 246 1.0907369940975837 #&gt; 247 1.0486826235693274 #&gt; 248 1.0082656206399931 #&gt; 249 0.9694282665755529 #&gt; 250 0.9320976601575675 #&gt; 251 0.8962339607475229 #&gt; 252 0.8617533865905884 #&gt; 253 0.8286151485833971 #&gt; 254 0.7967578289852474 #&gt; 255 0.7661404678425654 #&gt; 256 0.7367202044072118 #&gt; 257 0.708422713667491 #&gt; 258 0.6812311487720265 #&gt; 259 0.6550822696783506 #&gt; 260 0.6299469090210432 #&gt; 261 0.605786995355434 #&gt; 262 0.5825650778276774 #&gt; 263 0.5602382140936045 #&gt; 264 0.5387735503110371 #&gt; 265 0.5181403816556053 #&gt; 266 0.49830590931295304 #&gt; 267 0.47922937308117297 #&gt; 268 0.46088901492620127 #&gt; 269 0.44325464817119054 #&gt; 270 0.42630408406116316 #&gt; 271 0.41000543380657917 #&gt; 272 0.39433673295843236 #&gt; 273 0.37927114581493265 #&gt; 274 0.36478176529460243 #&gt; 275 0.35085044445134994 #&gt; 276 0.3374578361158044 #&gt; 277 0.32457682402453136 #&gt; 278 0.31219123729919207 #&gt; 279 0.300296586147234 #&gt; 280 0.28884848624094894 #&gt; 281 0.27783526470539743 #&gt; 282 0.26724487697010957 #&gt; 283 0.2570618106928273 #&gt; 284 0.2472693951468085 #&gt; 285 0.23785306876436113 #&gt; 286 0.22879648231270536 #&gt; 287 0.22008909643106767 #&gt; 288 0.21171318526106842 #&gt; 289 0.2036578219834066 #&gt; 290 0.19591133993811427 #&gt; 291 0.18846041746510728 #&gt; 292 0.18129477007162065 #&gt; 293 0.174405315161736 #&gt; 294 0.16777998120837712 #&gt; 295 0.16140610523836268 #&gt; 296 0.1552756501716649 #&gt; 297 0.14937904644542377 #&gt; 298 0.14370793039467633 #&gt; 299 0.13825290527822973 #&gt; 300 0.13300640130439656 #&gt; 301 0.12796012311324031 #&gt; 302 0.12310750541656884 #&gt; 303 0.11844182274749851 #&gt; 304 0.11395158652041627 #&gt; 305 0.10963187686672912 #&gt; 306 0.10547640155933785 #&gt; 307 0.10148022089409026 #&gt; 308 0.0976363799328684 #&gt; 309 0.09393976586801374 #&gt; 310 0.09038186218007657 #&gt; 311 0.08696004033318867 #&gt; 312 0.08366808215670352 #&gt; 313 0.08050159133387036 #&gt; 314 0.0774556507265311 #&gt; 315 0.07452541616811464 #&gt; 316 0.07170677388789805 #&gt; 317 0.06899492388917926 #&gt; 318 0.06638632065320674 #&gt; 319 0.06387707772657374 #&gt; 320 0.06146291085125196 #&gt; 321 0.0591402294396231 #&gt; 322 0.05690662209831464 #&gt; 323 0.05475707395743591 #&gt; 324 0.05268944906989688 #&gt; 325 0.05069984545069233 #&gt; 326 0.048785688597973095 #&gt; 327 0.046944795197577285 #&gt; 328 0.045173966618895535 #&gt; 329 0.043469382749897256 #&gt; 330 0.04182932192085659 #&gt; 331 0.04025154186795582 #&gt; 332 0.038733588417595735 #&gt; 333 0.03727299017402862 #&gt; 334 0.03586799441058297 #&gt; 335 0.03451589218265247 #&gt; 336 0.03321501089199479 #&gt; 337 0.03196371785309425 #&gt; 338 0.030759357425241718 #&gt; 339 0.029600888472444742 #&gt; 340 0.028485919148238392 #&gt; 341 0.02741317225069457 #&gt; 342 0.026380963792005673 #&gt; 343 0.025387828276963217 #&gt; 344 0.02443225636975702 #&gt; 345 0.02351279471955997 #&gt; 346 0.02262815392798661 #&gt; 347 0.02177684408442846 #&gt; 348 0.02095765200803268 #&gt; 349 0.02016947466161515 #&gt; 350 0.019410962895712616 #&gt; 351 0.018681045066734122 #&gt; 352 0.017978879513468316 #&gt; 353 0.017303468563130222 #&gt; 354 0.016653437842251186 #&gt; 355 0.01602766278432409 #&gt; 356 0.015425464893044428 #&gt; 357 0.01484594678906112 #&gt; 358 0.014288249850265784 #&gt; 359 0.01375163575426638 #&gt; 360 0.01323528665049373 #&gt; 361 0.012738339025978556 #&gt; 362 0.012260186918304262 #&gt; 363 0.011799970856220952 #&gt; 364 0.011357085981162363 #&gt; 365 0.010930950268775873 #&gt; 366 0.010520842685022909 #&gt; 367 0.010126145830079638 #&gt; 368 0.009746393154855839 #&gt; 369 0.009380889339520658 #&gt; 370 0.009029161386689313 #&gt; 371 0.00869059833698051 #&gt; 372 0.00836477207696539 #&gt; 373 0.008051209390678065 #&gt; 374 0.0077494325069793705 #&gt; 375 0.007459023266150334 #&gt; 376 0.007179590434333104 #&gt; 377 0.006910623445853765 #&gt; 378 0.006651749941578513 #&gt; 379 0.006402648026678379 #&gt; 380 0.006162978285307884 #&gt; 381 0.005932194796367616 #&gt; 382 0.005710085052295781 #&gt; 383 0.005496310244895275 #&gt; 384 0.0052906289241425215 #&gt; 385 0.0050926241688279104 #&gt; 386 0.004902076613033862 #&gt; 387 0.004718638851167859 #&gt; 388 0.004542078962047164 #&gt; 389 0.004372164586665975 #&gt; 390 0.004208618626839021 #&gt; 391 0.004051226677923414 #&gt; 392 0.0038997374494828298 #&gt; 393 0.003753918301513866 #&gt; 394 0.003613561837935153 #&gt; 395 0.0034784786917529164 #&gt; 396 0.003348462575629662 #&gt; 397 0.003223327362263324 #&gt; 398 0.0031028635490837437 #&gt; 399 0.002986912218213565 #&gt; 400 0.002875348146367024 #&gt; 401 0.0027679524720207994 #&gt; 402 0.0026645903412969877 #&gt; 403 0.00256506728009952 #&gt; 404 0.0024692701898842025 #&gt; 405 0.0023770671718814063 #&gt; 406 0.0022883091777422303 #&gt; 407 0.0022029269889801703 #&gt; 408 0.0021207379368966914 #&gt; 409 0.0020415781423120893 #&gt; 410 0.001965380838191689 #&gt; 411 0.0018920388674650765 #&gt; 412 0.0018214489876606395 #&gt; 413 0.0017534990549357195 #&gt; 414 0.0016880979054376358 #&gt; 415 0.0016251364192863505 #&gt; 416 0.0015645343026947606 #&gt; 417 0.0015062064772070694 #&gt; 418 0.0014500530088225327 #&gt; 419 0.0013959868097274688 #&gt; 420 0.001343946421404061 #&gt; 421 0.0012938496041169677 #&gt; 422 0.001245622397754905 #&gt; 423 0.0011992050880615885 #&gt; 424 0.0011545283489900085 #&gt; 425 0.0011115075856686302 #&gt; 426 0.001070100670544413 #&gt; 427 0.0010302364937566674 #&gt; 428 0.0009918591300819473 #&gt; 429 0.000954924393232083 #&gt; 430 0.0009193639132775486 #&gt; 431 0.0008851308467932729 #&gt; 432 0.0008521777959560448 #&gt; 433 0.0008204570911784497 #&gt; 434 0.0007899223397731109 #&gt; 435 0.0007605278374214596 #&gt; 436 0.0007322343466954752 #&gt; 437 0.0007049830914115257 #&gt; 438 0.0006787512341473519 #&gt; 439 0.00065350212037464 #&gt; 440 0.0006291921955255096 #&gt; 441 0.0006057856348208776 #&gt; 442 0.0005832525024800561 #&gt; 443 0.0005615598539424442 #&gt; 444 0.0005406761235200468 #&gt; 445 0.0005205750249286578 #&gt; 446 0.0005012184845940066 #&gt; 447 0.0004825848028301716 #&gt; 448 0.0004646447575300741 #&gt; 449 0.0004473739461918762 #&gt; 450 0.0004307513759213604 #&gt; 451 0.00041474810355609723 #&gt; 452 0.00039933580480713945 #&gt; 453 0.0003844970781264902 #&gt; 454 0.0003702109250696993 #&gt; 455 0.00035645948619340297 #&gt; 456 0.0003432213223641764 #&gt; 457 0.0003304723731848576 #&gt; 458 0.00031819830164465815 #&gt; 459 0.00030638121798918724 #&gt; 460 0.0002950045353519474 #&gt; 461 0.0002840533130499193 #&gt; 462 0.00027350873727298176 #&gt; 463 0.00026335657398426546 #&gt; 464 0.000253581258369829 #&gt; 465 0.00024416913722126747 #&gt; 466 0.0002351142689424904 #&gt; 467 0.0002263919313737711 #&gt; 468 0.00021799257674327073 #&gt; 469 0.00020990427540056088 #&gt; 470 0.0002021174506938248 #&gt; 471 0.00019462054044199915 #&gt; 472 0.00018740325426984858 #&gt; 473 0.00018045252249983815 #&gt; 474 0.000173759960543912 #&gt; 475 0.00016731630060690805 #&gt; 476 0.0001611122710715995 #&gt; 477 0.00015513993832625702 #&gt; 478 0.00014938925941558148 #&gt; 479 0.00014385207870578823 #&gt; 480 0.00013852014130375656 #&gt; 481 0.00013338601187671428 #&gt; 482 0.000128442793294424 #&gt; 483 0.0001236841045646944 #&gt; 484 0.00011910150087090696 #&gt; 485 0.00011468967274610794 #&gt; 486 0.00011044058002490428 #&gt; 487 0.00010634983745106246 #&gt; 488 0.00010241132940006558 #&gt; 489 9.861901302344988e-05 #&gt; 490 9.496682985475842e-05 #&gt; 491 9.144989845880715e-05 #&gt; 492 8.806354488018214e-05 #&gt; 493 8.480312707749194e-05 #&gt; 494 8.166404591653792e-05 #&gt; 495 7.864135637113095e-05 #&gt; 496 7.573027443124469e-05 #&gt; 497 7.292787602990206e-05 #&gt; 498 7.023030228370285e-05 #&gt; 499 6.763183953445079e-05 toc = time.process_time() print(toc - tic, &quot;seconds&quot;) #&gt; 6.686967006 seconds 12.3 A neural network with r-base It is the same algorithm above in numpy but written in R base. library(tictoc) tic() set.seed(123) N &lt;- 64; D_in &lt;- 1000; H &lt;- 100; D_out &lt;- 10; # Create random input and output data x &lt;- array(rnorm(N * D_in), dim = c(N, D_in)) y &lt;- array(rnorm(N * D_out), dim = c(N, D_out)) # Randomly initialize weights w1 &lt;- array(rnorm(D_in * H), dim = c(D_in, H)) w2 &lt;- array(rnorm(H * D_out), dim = c(H, D_out)) learning_rate &lt;- 1e-6 for (t in seq(1, 500)) { # Forward pass: compute predicted y h = x %*% w1 h_relu = pmax(h, 0) y_pred = h_relu %*% w2 # Compute and print loss sq &lt;- (y_pred - y)^2 loss = sum(sq) cat(t, loss, &quot;\\n&quot;) # Backprop to compute gradients of w1 and w2 with respect to loss grad_y_pred = 2.0 * (y_pred - y) grad_w2 = t(h_relu) %*% grad_y_pred grad_h_relu = grad_y_pred %*% t(w2) # grad_h &lt;- sapply(grad_h_relu, function(i) i, simplify = FALSE ) # grad_h = grad_h_relu.copy() grad_h &lt;- rlang::duplicate(grad_h_relu) grad_h[h &lt; 0] &lt;- 0 grad_w1 = t(x) %*% grad_h # Update weights w1 = w1 - learning_rate * grad_w1 w2 = w2 - learning_rate * grad_w2 } toc() #&gt; 1 2.8e+07 #&gt; 2 25505803 #&gt; 3 29441299 #&gt; 4 35797650 #&gt; 5 39517126 #&gt; 6 34884942 #&gt; 7 23333535 #&gt; 8 11927525 #&gt; 9 5352787 #&gt; 10 2496984 #&gt; 11 1379780 #&gt; 12 918213 #&gt; 13 695760 #&gt; 14 564974 #&gt; 15 474479 #&gt; 16 405370 #&gt; 17 349747 #&gt; 18 303724 #&gt; 19 265075 #&gt; 20 232325 #&gt; 21 204394 #&gt; 22 180414 #&gt; 23 159752 #&gt; 24 141895 #&gt; 25 126374 #&gt; 26 112820 #&gt; 27 100959 #&gt; 28 90536 #&gt; 29 81352 #&gt; 30 73244 #&gt; 31 66058 #&gt; 32 59675 #&gt; 33 53993 #&gt; 34 48921 #&gt; 35 44388 #&gt; 36 40328 #&gt; 37 36687 #&gt; 38 33414 #&gt; 39 30469 #&gt; 40 27816 #&gt; 41 25419 #&gt; 42 23251 #&gt; 43 21288 #&gt; 44 19508 #&gt; 45 17893 #&gt; 46 16426 #&gt; 47 15092 #&gt; 48 13877 #&gt; 49 12769 #&gt; 50 11758 #&gt; 51 10835 #&gt; 52 9991 #&gt; 53 9218 #&gt; 54 8510 #&gt; 55 7862 #&gt; 56 7267 #&gt; 57 6719 #&gt; 58 6217 #&gt; 59 5754 #&gt; 60 5329 #&gt; 61 4938 #&gt; 62 4577 #&gt; 63 4245 #&gt; 64 3938 #&gt; 65 3655 #&gt; 66 3394 #&gt; 67 3153 #&gt; 68 2930 #&gt; 69 2724 #&gt; 70 2533 #&gt; 71 2357 #&gt; 72 2193 #&gt; 73 2042 #&gt; 74 1902 #&gt; 75 1772 #&gt; 76 1651 #&gt; 77 1539 #&gt; 78 1435 #&gt; 79 1338 #&gt; 80 1249 #&gt; 81 1165 #&gt; 82 1088 #&gt; 83 1016 #&gt; 84 949 #&gt; 85 886 #&gt; 86 828 #&gt; 87 774 #&gt; 88 724 #&gt; 89 677 #&gt; 90 633 #&gt; 91 592 #&gt; 92 554 #&gt; 93 519 #&gt; 94 486 #&gt; 95 455 #&gt; 96 426 #&gt; 97 399 #&gt; 98 374 #&gt; 99 350 #&gt; 100 328 #&gt; 101 308 #&gt; 102 289 #&gt; 103 271 #&gt; 104 254 #&gt; 105 238 #&gt; 106 224 #&gt; 107 210 #&gt; 108 197 #&gt; 109 185 #&gt; 110 174 #&gt; 111 163 #&gt; 112 153 #&gt; 113 144 #&gt; 114 135 #&gt; 115 127 #&gt; 116 119 #&gt; 117 112 #&gt; 118 106 #&gt; 119 99.2 #&gt; 120 93.3 #&gt; 121 87.8 #&gt; 122 82.6 #&gt; 123 77.7 #&gt; 124 73.1 #&gt; 125 68.8 #&gt; 126 64.7 #&gt; 127 60.9 #&gt; 128 57.4 #&gt; 129 54 #&gt; 130 50.9 #&gt; 131 47.9 #&gt; 132 45.1 #&gt; 133 42.5 #&gt; 134 40.1 #&gt; 135 37.8 #&gt; 136 35.6 #&gt; 137 33.5 #&gt; 138 31.6 #&gt; 139 29.8 #&gt; 140 28.1 #&gt; 141 26.5 #&gt; 142 25 #&gt; 143 23.6 #&gt; 144 22.2 #&gt; 145 21 #&gt; 146 19.8 #&gt; 147 18.7 #&gt; 148 17.6 #&gt; 149 16.6 #&gt; 150 15.7 #&gt; 151 14.8 #&gt; 152 14 #&gt; 153 13.2 #&gt; 154 12.5 #&gt; 155 11.8 #&gt; 156 11.1 #&gt; 157 10.5 #&gt; 158 9.94 #&gt; 159 9.39 #&gt; 160 8.87 #&gt; 161 8.38 #&gt; 162 7.92 #&gt; 163 7.49 #&gt; 164 7.08 #&gt; 165 6.69 #&gt; 166 6.32 #&gt; 167 5.98 #&gt; 168 5.65 #&gt; 169 5.35 #&gt; 170 5.06 #&gt; 171 4.78 #&gt; 172 4.52 #&gt; 173 4.28 #&gt; 174 4.05 #&gt; 175 3.83 #&gt; 176 3.62 #&gt; 177 3.43 #&gt; 178 3.25 #&gt; 179 3.07 #&gt; 180 2.91 #&gt; 181 2.75 #&gt; 182 2.6 #&gt; 183 2.47 #&gt; 184 2.33 #&gt; 185 2.21 #&gt; 186 2.09 #&gt; 187 1.98 #&gt; 188 1.88 #&gt; 189 1.78 #&gt; 190 1.68 #&gt; 191 1.6 #&gt; 192 1.51 #&gt; 193 1.43 #&gt; 194 1.36 #&gt; 195 1.29 #&gt; 196 1.22 #&gt; 197 1.15 #&gt; 198 1.09 #&gt; 199 1.04 #&gt; 200 0.983 #&gt; 201 0.932 #&gt; 202 0.883 #&gt; 203 0.837 #&gt; 204 0.794 #&gt; 205 0.753 #&gt; 206 0.714 #&gt; 207 0.677 #&gt; 208 0.642 #&gt; 209 0.609 #&gt; 210 0.577 #&gt; 211 0.548 #&gt; 212 0.519 #&gt; 213 0.493 #&gt; 214 0.467 #&gt; 215 0.443 #&gt; 216 0.421 #&gt; 217 0.399 #&gt; 218 0.379 #&gt; 219 0.359 #&gt; 220 0.341 #&gt; 221 0.324 #&gt; 222 0.307 #&gt; 223 0.292 #&gt; 224 0.277 #&gt; 225 0.263 #&gt; 226 0.249 #&gt; 227 0.237 #&gt; 228 0.225 #&gt; 229 0.213 #&gt; 230 0.203 #&gt; 231 0.192 #&gt; 232 0.183 #&gt; 233 0.173 #&gt; 234 0.165 #&gt; 235 0.156 #&gt; 236 0.149 #&gt; 237 0.141 #&gt; 238 0.134 #&gt; 239 0.127 #&gt; 240 0.121 #&gt; 241 0.115 #&gt; 242 0.109 #&gt; 243 0.104 #&gt; 244 0.0985 #&gt; 245 0.0936 #&gt; 246 0.0889 #&gt; 247 0.0845 #&gt; 248 0.0803 #&gt; 249 0.0763 #&gt; 250 0.0725 #&gt; 251 0.0689 #&gt; 252 0.0655 #&gt; 253 0.0623 #&gt; 254 0.0592 #&gt; 255 0.0563 #&gt; 256 0.0535 #&gt; 257 0.0508 #&gt; 258 0.0483 #&gt; 259 0.0459 #&gt; 260 0.0437 #&gt; 261 0.0415 #&gt; 262 0.0395 #&gt; 263 0.0375 #&gt; 264 0.0357 #&gt; 265 0.0339 #&gt; 266 0.0323 #&gt; 267 0.0307 #&gt; 268 0.0292 #&gt; 269 0.0278 #&gt; 270 0.0264 #&gt; 271 0.0251 #&gt; 272 0.0239 #&gt; 273 0.0227 #&gt; 274 0.0216 #&gt; 275 0.0206 #&gt; 276 0.0196 #&gt; 277 0.0186 #&gt; 278 0.0177 #&gt; 279 0.0168 #&gt; 280 0.016 #&gt; 281 0.0152 #&gt; 282 0.0145 #&gt; 283 0.0138 #&gt; 284 0.0131 #&gt; 285 0.0125 #&gt; 286 0.0119 #&gt; 287 0.0113 #&gt; 288 0.0108 #&gt; 289 0.0102 #&gt; 290 0.00975 #&gt; 291 0.00927 #&gt; 292 0.00883 #&gt; 293 0.0084 #&gt; 294 0.008 #&gt; 295 0.00761 #&gt; 296 0.00724 #&gt; 297 0.0069 #&gt; 298 0.00656 #&gt; 299 0.00625 #&gt; 300 0.00595 #&gt; 301 0.00566 #&gt; 302 0.00539 #&gt; 303 0.00513 #&gt; 304 0.00489 #&gt; 305 0.00465 #&gt; 306 0.00443 #&gt; 307 0.00422 #&gt; 308 0.00401 #&gt; 309 0.00382 #&gt; 310 0.00364 #&gt; 311 0.00347 #&gt; 312 0.0033 #&gt; 313 0.00314 #&gt; 314 0.00299 #&gt; 315 0.00285 #&gt; 316 0.00271 #&gt; 317 0.00259 #&gt; 318 0.00246 #&gt; 319 0.00234 #&gt; 320 0.00223 #&gt; 321 0.00213 #&gt; 322 0.00203 #&gt; 323 0.00193 #&gt; 324 0.00184 #&gt; 325 0.00175 #&gt; 326 0.00167 #&gt; 327 0.00159 #&gt; 328 0.00151 #&gt; 329 0.00144 #&gt; 330 0.00137 #&gt; 331 0.00131 #&gt; 332 0.00125 #&gt; 333 0.00119 #&gt; 334 0.00113 #&gt; 335 0.00108 #&gt; 336 0.00103 #&gt; 337 0.000979 #&gt; 338 0.000932 #&gt; 339 0.000888 #&gt; 340 0.000846 #&gt; 341 0.000807 #&gt; 342 0.000768 #&gt; 343 0.000732 #&gt; 344 0.000698 #&gt; 345 0.000665 #&gt; 346 0.000634 #&gt; 347 0.000604 #&gt; 348 0.000575 #&gt; 349 0.000548 #&gt; 350 0.000523 #&gt; 351 0.000498 #&gt; 352 0.000475 #&gt; 353 0.000452 #&gt; 354 0.000431 #&gt; 355 0.000411 #&gt; 356 0.000392 #&gt; 357 0.000373 #&gt; 358 0.000356 #&gt; 359 0.000339 #&gt; 360 0.000323 #&gt; 361 0.000308 #&gt; 362 0.000294 #&gt; 363 0.00028 #&gt; 364 0.000267 #&gt; 365 0.000254 #&gt; 366 0.000243 #&gt; 367 0.000231 #&gt; 368 0.00022 #&gt; 369 0.00021 #&gt; 370 2e-04 #&gt; 371 0.000191 #&gt; 372 0.000182 #&gt; 373 0.000174 #&gt; 374 0.000165 #&gt; 375 0.000158 #&gt; 376 0.00015 #&gt; 377 0.000143 #&gt; 378 0.000137 #&gt; 379 0.00013 #&gt; 380 0.000124 #&gt; 381 0.000119 #&gt; 382 0.000113 #&gt; 383 0.000108 #&gt; 384 0.000103 #&gt; 385 9.8e-05 #&gt; 386 9.34e-05 #&gt; 387 8.91e-05 #&gt; 388 8.49e-05 #&gt; 389 8.1e-05 #&gt; 390 7.72e-05 #&gt; 391 7.37e-05 #&gt; 392 7.02e-05 #&gt; 393 6.7e-05 #&gt; 394 6.39e-05 #&gt; 395 6.09e-05 #&gt; 396 5.81e-05 #&gt; 397 5.54e-05 #&gt; 398 5.28e-05 #&gt; 399 5.04e-05 #&gt; 400 4.81e-05 #&gt; 401 4.58e-05 #&gt; 402 4.37e-05 #&gt; 403 4.17e-05 #&gt; 404 3.98e-05 #&gt; 405 3.79e-05 #&gt; 406 3.62e-05 #&gt; 407 3.45e-05 #&gt; 408 3.29e-05 #&gt; 409 3.14e-05 #&gt; 410 2.99e-05 #&gt; 411 2.86e-05 #&gt; 412 2.72e-05 #&gt; 413 2.6e-05 #&gt; 414 2.48e-05 #&gt; 415 2.36e-05 #&gt; 416 2.25e-05 #&gt; 417 2.15e-05 #&gt; 418 2.05e-05 #&gt; 419 1.96e-05 #&gt; 420 1.87e-05 #&gt; 421 1.78e-05 #&gt; 422 1.7e-05 #&gt; 423 1.62e-05 #&gt; 424 1.55e-05 #&gt; 425 1.48e-05 #&gt; 426 1.41e-05 #&gt; 427 1.34e-05 #&gt; 428 1.28e-05 #&gt; 429 1.22e-05 #&gt; 430 1.17e-05 #&gt; 431 1.11e-05 #&gt; 432 1.06e-05 #&gt; 433 1.01e-05 #&gt; 434 9.66e-06 #&gt; 435 9.22e-06 #&gt; 436 8.79e-06 #&gt; 437 8.39e-06 #&gt; 438 8e-06 #&gt; 439 7.64e-06 #&gt; 440 7.29e-06 #&gt; 441 6.95e-06 #&gt; 442 6.63e-06 #&gt; 443 6.33e-06 #&gt; 444 6.04e-06 #&gt; 445 5.76e-06 #&gt; 446 5.5e-06 #&gt; 447 5.25e-06 #&gt; 448 5.01e-06 #&gt; 449 4.78e-06 #&gt; 450 4.56e-06 #&gt; 451 4.35e-06 #&gt; 452 4.15e-06 #&gt; 453 3.96e-06 #&gt; 454 3.78e-06 #&gt; 455 3.61e-06 #&gt; 456 3.44e-06 #&gt; 457 3.28e-06 #&gt; 458 3.13e-06 #&gt; 459 2.99e-06 #&gt; 460 2.85e-06 #&gt; 461 2.72e-06 #&gt; 462 2.6e-06 #&gt; 463 2.48e-06 #&gt; 464 2.37e-06 #&gt; 465 2.26e-06 #&gt; 466 2.15e-06 #&gt; 467 2.06e-06 #&gt; 468 1.96e-06 #&gt; 469 1.87e-06 #&gt; 470 1.79e-06 #&gt; 471 1.71e-06 #&gt; 472 1.63e-06 #&gt; 473 1.55e-06 #&gt; 474 1.48e-06 #&gt; 475 1.42e-06 #&gt; 476 1.35e-06 #&gt; 477 1.29e-06 #&gt; 478 1.23e-06 #&gt; 479 1.17e-06 #&gt; 480 1.12e-06 #&gt; 481 1.07e-06 #&gt; 482 1.02e-06 #&gt; 483 9.74e-07 #&gt; 484 9.3e-07 #&gt; 485 8.88e-07 #&gt; 486 8.47e-07 #&gt; 487 8.09e-07 #&gt; 488 7.72e-07 #&gt; 489 7.37e-07 #&gt; 490 7.03e-07 #&gt; 491 6.71e-07 #&gt; 492 6.41e-07 #&gt; 493 6.12e-07 #&gt; 494 5.84e-07 #&gt; 495 5.57e-07 #&gt; 496 5.32e-07 #&gt; 497 5.08e-07 #&gt; 498 4.85e-07 #&gt; 499 4.63e-07 #&gt; 500 4.42e-07 #&gt; 1.901 sec elapsed 12.4 A PyTorch neural network Here is the same example we have used above but written in PyTorch. Notice the following differences with the numpy code: we select the computation device which could be cpu or gpu when building or creating the tensors, we specify which device we want to use the tensors have torch methods and properties. Example: mm(), clamp(), sum(), clone(), and t(), also notice the use some torch functions: device(), randn() reticulate::use_condaenv(&quot;r-torch&quot;) # Code in file tensor/two_layer_net_tensor.py import torch import time ms = torch.manual_seed(0) tic = time.process_time() device = torch.device(&#39;cpu&#39;) # device = torch.device(&#39;cuda&#39;) # Uncomment this to run on GPU # N is batch size; D_in is input dimension; # H is hidden dimension; D_out is output dimension. N, D_in, H, D_out = 64, 1000, 100, 10 # Create random input and output data x = torch.randn(N, D_in, device=device) y = torch.randn(N, D_out, device=device) # Randomly initialize weights w1 = torch.randn(D_in, H, device=device) w2 = torch.randn(H, D_out, device=device) learning_rate = 1e-6 for t in range(500): # Forward pass: compute predicted y h = x.mm(w1) h_relu = h.clamp(min=0) y_pred = h_relu.mm(w2) # Compute and print loss; loss is a scalar, and is stored in a PyTorch Tensor # of shape (); we can get its value as a Python number with loss.item(). loss = (y_pred - y).pow(2).sum() print(t, loss.item()) # Backprop to compute gradients of w1 and w2 with respect to loss grad_y_pred = 2.0 * (y_pred - y) grad_w2 = h_relu.t().mm(grad_y_pred) grad_h_relu = grad_y_pred.mm(w2.t()) grad_h = grad_h_relu.clone() grad_h[h &lt; 0] = 0 grad_w1 = x.t().mm(grad_h) # Update weights using gradient descent w1 -= learning_rate * grad_w1 w2 -= learning_rate * grad_w2 #&gt; 0 29428664.0 #&gt; 1 22739448.0 #&gt; 2 20605260.0 #&gt; 3 19520372.0 #&gt; 4 17810224.0 #&gt; 5 14999204.0 #&gt; 6 11483334.0 #&gt; 7 8096649.0 #&gt; 8 5398717.5 #&gt; 9 3521559.75 #&gt; 10 2315861.5 #&gt; 11 1570273.5 #&gt; 12 1111700.375 #&gt; 13 825062.8125 #&gt; 14 639684.4375 #&gt; 15 514220.625 #&gt; 16 425155.3125 #&gt; 17 358904.5625 #&gt; 18 307636.71875 #&gt; 19 266625.90625 #&gt; 20 232998.625 #&gt; 21 204887.296875 #&gt; 22 181051.0625 #&gt; 23 160643.0 #&gt; 24 143036.09375 #&gt; 25 127729.578125 #&gt; 26 114360.25 #&gt; 27 102621.0234375 #&gt; 28 92276.9375 #&gt; 29 83144.0859375 #&gt; 30 75053.3984375 #&gt; 31 67870.3984375 #&gt; 32 61485.79296875 #&gt; 33 55786.6328125 #&gt; 34 50690.8515625 #&gt; 35 46128.6328125 #&gt; 36 42029.546875 #&gt; 37 38341.875 #&gt; 38 35017.33203125 #&gt; 39 32016.68359375 #&gt; 40 29303.43359375 #&gt; 41 26847.1484375 #&gt; 42 24620.376953125 #&gt; 43 22599.46875 #&gt; 44 20762.5625 #&gt; 45 19090.986328125 #&gt; 46 17568.359375 #&gt; 47 16180.1083984375 #&gt; 48 14911.99609375 #&gt; 49 13753.8525390625 #&gt; 50 12694.0205078125 #&gt; 51 11723.640625 #&gt; 52 10834.490234375 #&gt; 53 10019.25390625 #&gt; 54 9270.923828125 #&gt; 55 8583.36328125 #&gt; 56 7950.5625 #&gt; 57 7368.46875 #&gt; 58 6832.73779296875 #&gt; 59 6339.20703125 #&gt; 60 5884.1484375 #&gt; 61 5464.44384765625 #&gt; 62 5077.45849609375 #&gt; 63 4719.9833984375 #&gt; 64 4389.5400390625 #&gt; 65 4084.009765625 #&gt; 66 3801.313232421875 #&gt; 67 3539.627197265625 #&gt; 68 3297.266845703125 #&gt; 69 3072.8017578125 #&gt; 70 2864.869140625 #&gt; 71 2672.025390625 #&gt; 72 2493.096435546875 #&gt; 73 2326.89697265625 #&gt; 74 2172.523193359375 #&gt; 75 2029.1279296875 #&gt; 76 1895.768310546875 #&gt; 77 1771.71435546875 #&gt; 78 1656.3409423828125 #&gt; 79 1548.9505615234375 #&gt; 80 1448.9840087890625 #&gt; 81 1355.846923828125 #&gt; 82 1269.0556640625 #&gt; 83 1188.1507568359375 #&gt; 84 1112.7042236328125 #&gt; 85 1042.3167724609375 #&gt; 86 976.61328125 #&gt; 87 915.2999267578125 #&gt; 88 858.0404052734375 #&gt; 89 804.5496826171875 #&gt; 90 754.5780029296875 #&gt; 91 707.8599243164062 #&gt; 92 664.1988525390625 #&gt; 93 623.3640747070312 #&gt; 94 585.147216796875 #&gt; 95 549.3995971679688 #&gt; 96 515.9583740234375 #&gt; 97 484.6272277832031 #&gt; 98 455.28955078125 #&gt; 99 427.81829833984375 #&gt; 100 402.0847473144531 #&gt; 101 377.9535827636719 #&gt; 102 355.3477783203125 #&gt; 103 334.1396179199219 #&gt; 104 314.2633361816406 #&gt; 105 295.61749267578125 #&gt; 106 278.1217346191406 #&gt; 107 261.7001953125 #&gt; 108 246.2969512939453 #&gt; 109 231.8272247314453 #&gt; 110 218.24240112304688 #&gt; 111 205.48812866210938 #&gt; 112 193.5052490234375 #&gt; 113 182.24417114257812 #&gt; 114 171.66690063476562 #&gt; 115 161.72601318359375 #&gt; 116 152.3784942626953 #&gt; 117 143.59078979492188 #&gt; 118 135.32354736328125 #&gt; 119 127.55582427978516 #&gt; 120 120.24463653564453 #&gt; 121 113.36481475830078 #&gt; 122 106.89350128173828 #&gt; 123 100.80726623535156 #&gt; 124 95.07266998291016 #&gt; 125 89.6752700805664 #&gt; 126 84.59477233886719 #&gt; 127 79.80913543701172 #&gt; 128 75.30223083496094 #&gt; 129 71.0572509765625 #&gt; 130 67.05980682373047 #&gt; 131 63.292694091796875 #&gt; 132 59.7408447265625 #&gt; 133 56.394203186035156 #&gt; 134 53.243412017822266 #&gt; 135 50.2683219909668 #&gt; 136 47.46772003173828 #&gt; 137 44.82497787475586 #&gt; 138 42.33271408081055 #&gt; 139 39.983646392822266 #&gt; 140 37.76749801635742 #&gt; 141 35.67666244506836 #&gt; 142 33.70509338378906 #&gt; 143 31.84467124938965 #&gt; 144 30.089385986328125 #&gt; 145 28.432872772216797 #&gt; 146 26.869369506835938 #&gt; 147 25.39266586303711 #&gt; 148 23.999008178710938 #&gt; 149 22.684724807739258 #&gt; 150 21.4434757232666 #&gt; 151 20.270301818847656 #&gt; 152 19.164194107055664 #&gt; 153 18.11824607849121 #&gt; 154 17.131380081176758 #&gt; 155 16.199291229248047 #&gt; 156 15.318136215209961 #&gt; 157 14.486746788024902 #&gt; 158 13.700006484985352 #&gt; 159 12.957758903503418 #&gt; 160 12.256866455078125 #&gt; 161 11.593376159667969 #&gt; 162 10.96681022644043 #&gt; 163 10.374650955200195 #&gt; 164 9.815613746643066 #&gt; 165 9.286172866821289 #&gt; 166 8.78611946105957 #&gt; 167 8.313515663146973 #&gt; 168 7.866476058959961 #&gt; 169 7.443814754486084 #&gt; 170 7.044161319732666 #&gt; 171 6.666952133178711 #&gt; 172 6.309534072875977 #&gt; 173 5.9717559814453125 #&gt; 174 5.652008056640625 #&gt; 175 5.3500075340271 #&gt; 176 5.06421422958374 #&gt; 177 4.793882846832275 #&gt; 178 4.538228511810303 #&gt; 179 4.296501159667969 #&gt; 180 4.067446708679199 #&gt; 181 3.8510499000549316 #&gt; 182 3.6461739540100098 #&gt; 183 3.4524216651916504 #&gt; 184 3.2690694332122803 #&gt; 185 3.0956828594207764 #&gt; 186 2.9311866760253906 #&gt; 187 2.7758116722106934 #&gt; 188 2.628840684890747 #&gt; 189 2.4897918701171875 #&gt; 190 2.357895851135254 #&gt; 191 2.2333240509033203 #&gt; 192 2.1151578426361084 #&gt; 193 2.003354072570801 #&gt; 194 1.897698998451233 #&gt; 195 1.7976123094558716 #&gt; 196 1.7029246091842651 #&gt; 197 1.6131364107131958 #&gt; 198 1.5283033847808838 #&gt; 199 1.4478871822357178 #&gt; 200 1.371699333190918 #&gt; 201 1.2994897365570068 #&gt; 202 1.231500267982483 #&gt; 203 1.1667163372039795 #&gt; 204 1.1054186820983887 #&gt; 205 1.0472912788391113 #&gt; 206 0.9924129247665405 #&gt; 207 0.9405249953269958 #&gt; 208 0.8911417722702026 #&gt; 209 0.8445178866386414 #&gt; 210 0.8003085851669312 #&gt; 211 0.758423388004303 #&gt; 212 0.7187696099281311 #&gt; 213 0.6812056303024292 #&gt; 214 0.6455042362213135 #&gt; 215 0.6117878556251526 #&gt; 216 0.5798596739768982 #&gt; 217 0.5495442152023315 #&gt; 218 0.5209972858428955 #&gt; 219 0.4938827455043793 #&gt; 220 0.46809014678001404 #&gt; 221 0.4436979293823242 #&gt; 222 0.42065465450286865 #&gt; 223 0.3987467288970947 #&gt; 224 0.3779408633708954 #&gt; 225 0.35838788747787476 #&gt; 226 0.3397265076637268 #&gt; 227 0.3221140503883362 #&gt; 228 0.30536866188049316 #&gt; 229 0.2895379662513733 #&gt; 230 0.27451151609420776 #&gt; 231 0.2602919638156891 #&gt; 232 0.24681799113750458 #&gt; 233 0.23405984044075012 #&gt; 234 0.22187164425849915 #&gt; 235 0.2103630006313324 #&gt; 236 0.19945508241653442 #&gt; 237 0.18917179107666016 #&gt; 238 0.1794165074825287 #&gt; 239 0.1700771450996399 #&gt; 240 0.1613144725561142 #&gt; 241 0.152926966547966 #&gt; 242 0.14506009221076965 #&gt; 243 0.1375567466020584 #&gt; 244 0.13043273985385895 #&gt; 245 0.12370903044939041 #&gt; 246 0.11734490096569061 #&gt; 247 0.11129261553287506 #&gt; 248 0.10555146634578705 #&gt; 249 0.10010744631290436 #&gt; 250 0.09495128691196442 #&gt; 251 0.09006303548812866 #&gt; 252 0.08542166650295258 #&gt; 253 0.08105342835187912 #&gt; 254 0.07687549293041229 #&gt; 255 0.07293462008237839 #&gt; 256 0.06918356567621231 #&gt; 257 0.06564081460237503 #&gt; 258 0.062239713966846466 #&gt; 259 0.059055205434560776 #&gt; 260 0.05602336302399635 #&gt; 261 0.05314234644174576 #&gt; 262 0.05042209476232529 #&gt; 263 0.04785769432783127 #&gt; 264 0.045423999428749084 #&gt; 265 0.04309770092368126 #&gt; 266 0.04090772941708565 #&gt; 267 0.03880797326564789 #&gt; 268 0.03683297708630562 #&gt; 269 0.03495331108570099 #&gt; 270 0.03315659612417221 #&gt; 271 0.031475357711315155 #&gt; 272 0.029864072799682617 #&gt; 273 0.028345633298158646 #&gt; 274 0.026901375502347946 #&gt; 275 0.025526201352477074 #&gt; 276 0.024225471541285515 #&gt; 277 0.023021651431918144 #&gt; 278 0.021845556795597076 #&gt; 279 0.020738258957862854 #&gt; 280 0.01967737451195717 #&gt; 281 0.01868186891078949 #&gt; 282 0.017737826332449913 #&gt; 283 0.016843702644109726 #&gt; 284 0.015994098037481308 #&gt; 285 0.015187159180641174 #&gt; 286 0.014432456344366074 #&gt; 287 0.013691866770386696 #&gt; 288 0.013026118278503418 #&gt; 289 0.012365361675620079 #&gt; 290 0.011741021648049355 #&gt; 291 0.011153185740113258 #&gt; 292 0.010602883994579315 #&gt; 293 0.010070282965898514 #&gt; 294 0.009570850059390068 #&gt; 295 0.009099053218960762 #&gt; 296 0.008648849092423916 #&gt; 297 0.008217266760766506 #&gt; 298 0.007814647629857063 #&gt; 299 0.007436459884047508 #&gt; 300 0.007072300184518099 #&gt; 301 0.006720009259879589 #&gt; 302 0.006387100555002689 #&gt; 303 0.00608158390969038 #&gt; 304 0.00578821636736393 #&gt; 305 0.005504274740815163 #&gt; 306 0.005235536955296993 #&gt; 307 0.004986326675862074 #&gt; 308 0.004750200547277927 #&gt; 309 0.004520890768617392 #&gt; 310 0.004305804148316383 #&gt; 311 0.004104197025299072 #&gt; 312 0.003908107057213783 #&gt; 313 0.0037259890232235193 #&gt; 314 0.0035482768435031176 #&gt; 315 0.0033842488192021847 #&gt; 316 0.0032260832376778126 #&gt; 317 0.0030806262511759996 #&gt; 318 0.002938204212114215 #&gt; 319 0.002802144968882203 #&gt; 320 0.002674166578799486 #&gt; 321 0.0025522327050566673 #&gt; 322 0.0024338625371456146 #&gt; 323 0.002325983252376318 #&gt; 324 0.0022217126097530127 #&gt; 325 0.002122103003785014 #&gt; 326 0.0020273567643016577 #&gt; 327 0.0019368595676496625 #&gt; 328 0.0018519405275583267 #&gt; 329 0.0017723542405292392 #&gt; 330 0.0016958083724603057 #&gt; 331 0.00162519421428442 #&gt; 332 0.001555908122099936 #&gt; 333 0.0014901482500135899 #&gt; 334 0.0014247691724449396 #&gt; 335 0.0013653874630108476 #&gt; 336 0.001307258615270257 #&gt; 337 0.0012546550715342164 #&gt; 338 0.0012025412870571017 #&gt; 339 0.0011545777088031173 #&gt; 340 0.001107968739233911 #&gt; 341 0.0010642317356541753 #&gt; 342 0.0010200864635407925 #&gt; 343 0.0009793058270588517 #&gt; 344 0.0009410151396878064 #&gt; 345 0.0009048299980349839 #&gt; 346 0.0008693647105246782 #&gt; 347 0.000835308397654444 #&gt; 348 0.0008031500619836152 #&gt; 349 0.0007735351100564003 #&gt; 350 0.000744393328204751 #&gt; 351 0.00071698147803545 #&gt; 352 0.00069050322053954 #&gt; 353 0.0006645384710282087 #&gt; 354 0.0006397517863661051 #&gt; 355 0.0006177832838147879 #&gt; 356 0.0005949471960775554 #&gt; 357 0.0005744362715631723 #&gt; 358 0.0005537742399610579 #&gt; 359 0.0005348395789042115 #&gt; 360 0.0005162699380889535 #&gt; 361 0.000499469693750143 #&gt; 362 0.00048172459355555475 #&gt; 363 0.0004661969724111259 #&gt; 364 0.0004515194450505078 #&gt; 365 0.0004358708392828703 #&gt; 366 0.0004218583053443581 #&gt; 367 0.00040883725159801543 #&gt; 368 0.0003956131695304066 #&gt; 369 0.0003827497421298176 #&gt; 370 0.000370656605809927 #&gt; 371 0.00036004791036248207 #&gt; 372 0.0003480703162495047 #&gt; 373 0.0003388348559383303 #&gt; 374 0.000327684567309916 #&gt; 375 0.0003175089950673282 #&gt; 376 0.0003082627372350544 #&gt; 377 0.0002986858307849616 #&gt; 378 0.00028960598865523934 #&gt; 379 0.0002815576735883951 #&gt; 380 0.0002736181777436286 #&gt; 381 0.0002657140721566975 #&gt; 382 0.00025785667821764946 #&gt; 383 0.0002509196347091347 #&gt; 384 0.00024437913089059293 #&gt; 385 0.00023740741016808897 #&gt; 386 0.0002299495681654662 #&gt; 387 0.0002234804560430348 #&gt; 388 0.0002169939107261598 #&gt; 389 0.00021134663256816566 #&gt; 390 0.0002056143421214074 #&gt; 391 0.00020046206191182137 #&gt; 392 0.00019536828040145338 #&gt; 393 0.00019056514429394156 #&gt; 394 0.00018598540918901563 #&gt; 395 0.00018159380124416202 #&gt; 396 0.00017640764417592436 #&gt; 397 0.00017208821373060346 #&gt; 398 0.000168110869708471 #&gt; 399 0.00016350964142475277 #&gt; 400 0.00015964081103447825 #&gt; 401 0.00015596051525790244 #&gt; 402 0.00015269994037225842 #&gt; 403 0.00014866374840494245 #&gt; 404 0.00014477886725217104 #&gt; 405 0.00014148686022963375 #&gt; 406 0.00013842849875800312 #&gt; 407 0.00013507613039109856 #&gt; 408 0.0001322997995885089 #&gt; 409 0.00012896949192509055 #&gt; 410 0.00012618394976016134 #&gt; 411 0.00012356613297015429 #&gt; 412 0.00012060831068083644 #&gt; 413 0.00011798611376434565 #&gt; 414 0.0001152795521193184 #&gt; 415 0.00011272911069681868 #&gt; 416 0.00011033188638975844 #&gt; 417 0.00010773474059533328 #&gt; 418 0.00010584026313154027 #&gt; 419 0.00010329326323699206 #&gt; 420 0.00010140397353097796 #&gt; 421 9.970468090614304e-05 #&gt; 422 9.72362540778704e-05 #&gt; 423 9.54945498961024e-05 #&gt; 424 9.346337174065411e-05 #&gt; 425 9.128850797424093e-05 #&gt; 426 8.97917925613001e-05 #&gt; 427 8.779048221185803e-05 #&gt; 428 8.59305146150291e-05 #&gt; 429 8.416303899139166e-05 #&gt; 430 8.247063669841737e-05 #&gt; 431 8.109148620860651e-05 #&gt; 432 7.982019451446831e-05 #&gt; 433 7.818565791239962e-05 #&gt; 434 7.673520303796977e-05 #&gt; 435 7.54009815864265e-05 #&gt; 436 7.374506094492972e-05 #&gt; 437 7.267539331223816e-05 #&gt; 438 7.122510578483343e-05 #&gt; 439 6.98604853823781e-05 #&gt; 440 6.852982915006578e-05 #&gt; 441 6.75098126521334e-05 #&gt; 442 6.636354373767972e-05 #&gt; 443 6.522039620904252e-05 #&gt; 444 6.410140485968441e-05 #&gt; 445 6.307245348580182e-05 #&gt; 446 6.221079092938453e-05 #&gt; 447 6.089429371058941e-05 #&gt; 448 5.975936437607743e-05 #&gt; 449 5.893126945011318e-05 #&gt; 450 5.780566425528377e-05 #&gt; 451 5.694766514352523e-05 #&gt; 452 5.5986300139920786e-05 #&gt; 453 5.502309068106115e-05 #&gt; 454 5.420695379143581e-05 #&gt; 455 5.31858422618825e-05 #&gt; 456 5.239694655756466e-05 #&gt; 457 5.1775907195406035e-05 #&gt; 458 5.109262929181568e-05 #&gt; 459 5.0413200369803235e-05 #&gt; 460 4.956878183293156e-05 #&gt; 461 4.8856254579732195e-05 #&gt; 462 4.8221645556623116e-05 #&gt; 463 4.7429402911802754e-05 #&gt; 464 4.700458885054104e-05 #&gt; 465 4.615000216290355e-05 #&gt; 466 4.5314704038901255e-05 #&gt; 467 4.466490645427257e-05 #&gt; 468 4.406480729812756e-05 #&gt; 469 4.344138142187148e-05 #&gt; 470 4.302451270632446e-05 #&gt; 471 4.255307430867106e-05 #&gt; 472 4.1863419028231874e-05 #&gt; 473 4.148659354541451e-05 #&gt; 474 4.099802754353732e-05 #&gt; 475 4.034798257634975e-05 #&gt; 476 3.994005237473175e-05 #&gt; 477 3.94669477827847e-05 #&gt; 478 3.9117549022194e-05 #&gt; 479 3.8569156458834186e-05 #&gt; 480 3.8105612475192174e-05 #&gt; 481 3.753463170141913e-05 #&gt; 482 3.679965084302239e-05 #&gt; 483 3.646357436082326e-05 #&gt; 484 3.597680915845558e-05 #&gt; 485 3.555299190338701e-05 #&gt; 486 3.504360938677564e-05 #&gt; 487 3.449235737207346e-05 #&gt; 488 3.391931386431679e-05 #&gt; 489 3.374389780219644e-05 #&gt; 490 3.328040838823654e-05 #&gt; 491 3.31329574692063e-05 #&gt; 492 3.259751247242093e-05 #&gt; 493 3.2441555958939716e-05 #&gt; 494 3.1837684218771756e-05 #&gt; 495 3.1491359550273046e-05 #&gt; 496 3.120429755654186e-05 #&gt; 497 3.089967503910884e-05 #&gt; 498 3.059657319681719e-05 #&gt; 499 3.0050463465158828e-05 toc = time.process_time() print(toc - tic, &quot;seconds&quot;) #&gt; 56.936851472 seconds 12.5 A neural network in rTorch The example shows the long and manual way of calculating the forward and backward passes but using rTorch. The objective is getting familiarized with the rTorch tensor operations. The following example was converted from PyTorch to rTorch to show differences and similarities of both approaches. The original source can be found here: Source. 12.5.1 Load the libraries library(rTorch) library(ggplot2) device = torch$device(&#39;cpu&#39;) # device = torch.device(&#39;cuda&#39;) # Uncomment this to run on GPU invisible(torch$manual_seed(0)) N is batch size; D_in is input dimension; H is hidden dimension; D_out is output dimension. 12.5.2 Dataset We will create a random dataset for a two layer neural network. N &lt;- 64L; D_in &lt;- 1000L; H &lt;- 100L; D_out &lt;- 10L # Create random Tensors to hold inputs and outputs x &lt;- torch$randn(N, D_in, device=device) y &lt;- torch$randn(N, D_out, device=device) # dimensions of both tensors dim(x) dim(y) #&gt; [1] 64 1000 #&gt; [1] 64 10 12.5.3 Initialize the weights # Randomly initialize weights w1 &lt;- torch$randn(D_in, H, device=device) # layer 1 w2 &lt;- torch$randn(H, D_out, device=device) # layer 2 dim(w1) dim(w2) #&gt; [1] 1000 100 #&gt; [1] 100 10 12.5.4 Iterate through the dataset Now, we are going to train our neural network on the training dataset. The equestion is: “how many times do we have to expose the training data to the algorithm?”. By looking at the graph of the loss we may get an idea when we should stop. 12.5.4.1 Iterate 50 times Let’s say that for the sake of time we select to run only 50 iterations of the loop doing the training. learning_rate = 1e-6 # loop for (t in 1:50) { # Forward pass: compute predicted y, y_pred h &lt;- x$mm(w1) # matrix multiplication, x*w1 h_relu &lt;- h$clamp(min=0) # make elements greater than zero y_pred &lt;- h_relu$mm(w2) # matrix multiplication, h_relu*w2 # Compute and print loss; loss is a scalar, and is stored in a PyTorch Tensor # of shape (); we can get its value as a Python number with loss.item(). loss &lt;- (torch$sub(y_pred, y))$pow(2)$sum() # sum((y_pred-y)^2) # cat(t, &quot;\\t&quot;) # cat(loss$item(), &quot;\\n&quot;) # Backprop to compute gradients of w1 and w2 with respect to loss grad_y_pred &lt;- torch$mul(torch$scalar_tensor(2.0), torch$sub(y_pred, y)) grad_w2 &lt;- h_relu$t()$mm(grad_y_pred) # compute gradient of w2 grad_h_relu &lt;- grad_y_pred$mm(w2$t()) grad_h &lt;- grad_h_relu$clone() mask &lt;- grad_h$lt(0) # filter values lower than zero torch$masked_select(grad_h, mask)$fill_(0.0) # make them equal to zero grad_w1 &lt;- x$t()$mm(grad_h) # compute gradient of w1 # Update weights using gradient descent w1 &lt;- torch$sub(w1, torch$mul(learning_rate, grad_w1)) w2 &lt;- torch$sub(w2, torch$mul(learning_rate, grad_w2)) } # y vs predicted y df_50 &lt;- data.frame(y = y$flatten()$numpy(), y_pred = y_pred$flatten()$numpy(), iter = 50) ggplot(df_50, aes(x = y, y = y_pred)) + geom_point() We see a lot of dispersion between the predicted values, \\(y_{pred}\\) and the real values, \\(y\\). We are far from our goal. Let’s take a look at the dataframe: library(&#39;DT&#39;) datatable(df_50, options = list(pageLength = 10)) 12.5.4.2 A training function Now, we convert the script above to a function, so we could reuse it several times. We want to study the effect of the iteration on the performance of the algorithm. This time we create a function train to input the number of iterations that we want to run: train &lt;- function(iterations) { # Randomly initialize weights w1 &lt;- torch$randn(D_in, H, device=device) # layer 1 w2 &lt;- torch$randn(H, D_out, device=device) # layer 2 learning_rate = 1e-6 # loop for (t in 1:iterations) { # Forward pass: compute predicted y h &lt;- x$mm(w1) h_relu &lt;- h$clamp(min=0) y_pred &lt;- h_relu$mm(w2) # Compute and print loss; loss is a scalar stored in a PyTorch Tensor # of shape (); we can get its value as a Python number with loss.item(). loss &lt;- (torch$sub(y_pred, y))$pow(2)$sum() # cat(t, &quot;\\t&quot;); cat(loss$item(), &quot;\\n&quot;) # Backprop to compute gradients of w1 and w2 with respect to loss grad_y_pred &lt;- torch$mul(torch$scalar_tensor(2.0), torch$sub(y_pred, y)) grad_w2 &lt;- h_relu$t()$mm(grad_y_pred) grad_h_relu &lt;- grad_y_pred$mm(w2$t()) grad_h &lt;- grad_h_relu$clone() mask &lt;- grad_h$lt(0) torch$masked_select(grad_h, mask)$fill_(0.0) grad_w1 &lt;- x$t()$mm(grad_h) # Update weights using gradient descent w1 &lt;- torch$sub(w1, torch$mul(learning_rate, grad_w1)) w2 &lt;- torch$sub(w2, torch$mul(learning_rate, grad_w2)) } data.frame(y = y$flatten()$numpy(), y_pred = y_pred$flatten()$numpy(), iter = iterations) } 12.5.4.3 Run it at 100 iterations # retrieve the results and store them in a dataframe df_100 &lt;- train(iterations = 100) datatable(df_100, options = list(pageLength = 10)) # plot ggplot(df_100, aes(x = y_pred, y = y)) + geom_point() 12.5.4.4 250 iterations Still there are differences between the value and the prediction. Let’s try with more iterations, like 250: df_250 &lt;- train(iterations = 200) datatable(df_250, options = list(pageLength = 25)) # plot ggplot(df_250, aes(x = y_pred, y = y)) + geom_point() We see the formation of a line between the values and prediction, which means we are getting closer at finding the right algorithm, in this particular case, weights and bias. 12.5.4.5 500 iterations Let’s try one more time with 500 iterations: df_500 &lt;- train(iterations = 500) datatable(df_500, options = list(pageLength = 25)) ggplot(df_500, aes(x = y_pred, y = y)) + geom_point() 12.6 Full Neural Network in rTorch library(rTorch) library(ggplot2) library(tictoc) tic() device = torch$device(&#39;cpu&#39;) # device = torch.device(&#39;cuda&#39;) # Uncomment this to run on GPU invisible(torch$manual_seed(0)) # Properties of tensors and neural network N &lt;- 64L; D_in &lt;- 1000L; H &lt;- 100L; D_out &lt;- 10L # Create random Tensors to hold inputs and outputs x &lt;- torch$randn(N, D_in, device=device) y &lt;- torch$randn(N, D_out, device=device) # dimensions of both tensors # initialize the weights w1 &lt;- torch$randn(D_in, H, device=device) # layer 1 w2 &lt;- torch$randn(H, D_out, device=device) # layer 2 learning_rate = 1e-6 # loop for (t in 1:500) { # Forward pass: compute predicted y, y_pred h &lt;- x$mm(w1) # matrix multiplication, x*w1 h_relu &lt;- h$clamp(min=0) # make elements greater than zero y_pred &lt;- h_relu$mm(w2) # matrix multiplication, h_relu*w2 # Compute and print loss; loss is a scalar, and is stored in a PyTorch Tensor # of shape (); we can get its value as a Python number with loss.item(). loss &lt;- (torch$sub(y_pred, y))$pow(2)$sum() # sum((y_pred-y)^2) # cat(t, &quot;\\t&quot;) # cat(loss$item(), &quot;\\n&quot;) # Backprop to compute gradients of w1 and w2 with respect to loss grad_y_pred &lt;- torch$mul(torch$scalar_tensor(2.0), torch$sub(y_pred, y)) grad_w2 &lt;- h_relu$t()$mm(grad_y_pred) # compute gradient of w2 grad_h_relu &lt;- grad_y_pred$mm(w2$t()) grad_h &lt;- grad_h_relu$clone() mask &lt;- grad_h$lt(0) # filter values lower than zero torch$masked_select(grad_h, mask)$fill_(0.0) # make them equal to zero grad_w1 &lt;- x$t()$mm(grad_h) # compute gradient of w1 # Update weights using gradient descent w1 &lt;- torch$sub(w1, torch$mul(learning_rate, grad_w1)) w2 &lt;- torch$sub(w2, torch$mul(learning_rate, grad_w2)) } # y vs predicted y df&lt;- data.frame(y = y$flatten()$numpy(), y_pred = y_pred$flatten()$numpy(), iter = 500) datatable(df, options = list(pageLength = 25)) ggplot(df, aes(x = y_pred, y = y)) + geom_point() toc() #&gt; 25.361 sec elapsed 12.7 Exercise Rewrite the code in rTorch but including and plotting the loss at each iteration On the neural network written in PyTorch, code, instead of printing a long table, print the table by pages that we could navigate using vertical and horizontal bars. Tip: read the PyThon data structure from R and plot it with ggplot2 "],["a-neural-network-step-by-step.html", "Chapter 13 A neural network step-by-step 13.1 Introduction 13.2 Select device 13.3 Create the dataset 13.4 Define the model 13.5 The Loss function 13.6 Iterate through the dataset 13.7 Using R generics 13.8 An elegant neural network 13.9 A browseable dataframe 13.10 Plot the loss at each iteration", " Chapter 13 A neural network step-by-step Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 13.1 Introduction Source: https://github.com/jcjohnson/pytorch-examples#pytorch-nn In this example we use the torch nn package to implement our two-layer network: 13.2 Select device library(rTorch) device = torch$device(&#39;cpu&#39;) # device = torch.device(&#39;cuda&#39;) # Uncomment this to run on GPU N is batch size; D_in is input dimension; H is hidden dimension; D_out is output dimension. 13.3 Create the dataset invisible(torch$manual_seed(0)) # do not show the generator output N &lt;- 64L; D_in &lt;- 1000L; H &lt;- 100L; D_out &lt;- 10L # Create random Tensors to hold inputs and outputs x = torch$randn(N, D_in, device=device) y = torch$randn(N, D_out, device=device) 13.4 Define the model We use the nn package to define our model as a sequence of layers. nn.Sequential applies these leayers in sequence to produce an output. Each Linear Module computes the output by using a linear function, and holds also tensors for its weights and biases. After constructing the model we use the .to() method to move it to the desired device, which could be CPU or GPU. Remember that we selected CPU with torch$device('cpu'). model &lt;- torch$nn$Sequential( torch$nn$Linear(D_in, H), # first layer torch$nn$ReLU(), torch$nn$Linear(H, D_out))$to(device) # output layer print(model) #&gt; Sequential( #&gt; (0): Linear(in_features=1000, out_features=100, bias=True) #&gt; (1): ReLU() #&gt; (2): Linear(in_features=100, out_features=10, bias=True) #&gt; ) 13.5 The Loss function The nn package also contains definitions of several loss functions; in this case we will use Mean Squared Error (\\(MSE\\)) as our loss function. Setting reduction='sum' means that we are computing the sum of squared errors rather than the mean; this is for consistency with the examples above where we manually compute the loss, but in practice it is more common to use the mean squared error as a loss by setting reduction='elementwise_mean'. loss_fn = torch$nn$MSELoss(reduction = &#39;sum&#39;) 13.6 Iterate through the dataset learning_rate = 1e-4 for (t in 1:500) { # Forward pass: compute predicted y by passing x to the model. Module objects # override the __call__ operator so you can call them like functions. When # doing so you pass a Tensor of input data to the Module and it produces # a Tensor of output data. y_pred = model(x) # Compute and print loss. We pass Tensors containing the predicted and true # values of y, and the loss function returns a Tensor containing the loss. loss = loss_fn(y_pred, y) cat(t, &quot;\\t&quot;) cat(loss$item(), &quot;\\n&quot;) # Zero the gradients before running the backward pass. model$zero_grad() # Backward pass: compute gradient of the loss with respect to all the learnable # parameters of the model. Internally, the parameters of each Module are stored # in Tensors with requires_grad=True, so this call will compute gradients for # all learnable parameters in the model. loss$backward() # Update the weights using gradient descent. Each parameter is a Tensor, so # we can access its data and gradients like we did before. with(torch$no_grad(), { for (param in iterate(model$parameters())) { # in Python this code is much simpler. In R we have to do some conversions # param$data &lt;- torch$sub(param$data, # torch$mul(param$grad$float(), # torch$scalar_tensor(learning_rate))) param$data &lt;- param$data - param$grad * learning_rate } }) } #&gt; 1 628 #&gt; 2 585 #&gt; 3 547 #&gt; 4 513 #&gt; 5 482 #&gt; 6 455 #&gt; 7 430 #&gt; 8 406 #&gt; 9 385 #&gt; 10 364 #&gt; 11 345 #&gt; 12 328 #&gt; 13 311 #&gt; 14 295 #&gt; 15 280 #&gt; 16 265 #&gt; 17 252 #&gt; 18 239 #&gt; 19 226 #&gt; 20 214 #&gt; 21 203 #&gt; 22 192 #&gt; 23 181 #&gt; 24 172 #&gt; 25 162 #&gt; 26 153 #&gt; 27 145 #&gt; 28 137 #&gt; 29 129 #&gt; 30 122 #&gt; 31 115 #&gt; 32 109 #&gt; 33 103 #&gt; 34 96.9 #&gt; 35 91.5 #&gt; 36 86.3 #&gt; 37 81.5 #&gt; 38 76.9 #&gt; 39 72.6 #&gt; 40 68.5 #&gt; 41 64.6 #&gt; 42 61 #&gt; 43 57.6 #&gt; 44 54.3 #&gt; 45 51.3 #&gt; 46 48.5 #&gt; 47 45.8 #&gt; 48 43.2 #&gt; 49 40.9 #&gt; 50 38.6 #&gt; 51 36.5 #&gt; 52 34.5 #&gt; 53 32.7 #&gt; 54 30.9 #&gt; 55 29.3 #&gt; 56 27.8 #&gt; 57 26.3 #&gt; 58 24.9 #&gt; 59 23.7 #&gt; 60 22.4 #&gt; 61 21.3 #&gt; 62 20.2 #&gt; 63 19.2 #&gt; 64 18.2 #&gt; 65 17.3 #&gt; 66 16.5 #&gt; 67 15.7 #&gt; 68 14.9 #&gt; 69 14.2 #&gt; 70 13.5 #&gt; 71 12.9 #&gt; 72 12.3 #&gt; 73 11.7 #&gt; 74 11.1 #&gt; 75 10.6 #&gt; 76 10.1 #&gt; 77 9.67 #&gt; 78 9.24 #&gt; 79 8.82 #&gt; 80 8.42 #&gt; 81 8.05 #&gt; 82 7.69 #&gt; 83 7.35 #&gt; 84 7.03 #&gt; 85 6.72 #&gt; 86 6.43 #&gt; 87 6.16 #&gt; 88 5.9 #&gt; 89 5.65 #&gt; 90 5.41 #&gt; 91 5.18 #&gt; 92 4.97 #&gt; 93 4.76 #&gt; 94 4.57 #&gt; 95 4.38 #&gt; 96 4.2 #&gt; 97 4.03 #&gt; 98 3.87 #&gt; 99 3.72 #&gt; 100 3.57 #&gt; 101 3.43 #&gt; 102 3.29 #&gt; 103 3.17 #&gt; 104 3.04 #&gt; 105 2.92 #&gt; 106 2.81 #&gt; 107 2.7 #&gt; 108 2.6 #&gt; 109 2.5 #&gt; 110 2.41 #&gt; 111 2.31 #&gt; 112 2.23 #&gt; 113 2.14 #&gt; 114 2.06 #&gt; 115 1.99 #&gt; 116 1.91 #&gt; 117 1.84 #&gt; 118 1.77 #&gt; 119 1.71 #&gt; 120 1.65 #&gt; 121 1.59 #&gt; 122 1.53 #&gt; 123 1.47 #&gt; 124 1.42 #&gt; 125 1.37 #&gt; 126 1.32 #&gt; 127 1.27 #&gt; 128 1.23 #&gt; 129 1.18 #&gt; 130 1.14 #&gt; 131 1.1 #&gt; 132 1.06 #&gt; 133 1.02 #&gt; 134 0.989 #&gt; 135 0.954 #&gt; 136 0.921 #&gt; 137 0.889 #&gt; 138 0.858 #&gt; 139 0.828 #&gt; 140 0.799 #&gt; 141 0.772 #&gt; 142 0.745 #&gt; 143 0.719 #&gt; 144 0.695 #&gt; 145 0.671 #&gt; 146 0.648 #&gt; 147 0.626 #&gt; 148 0.605 #&gt; 149 0.584 #&gt; 150 0.564 #&gt; 151 0.545 #&gt; 152 0.527 #&gt; 153 0.509 #&gt; 154 0.492 #&gt; 155 0.476 #&gt; 156 0.46 #&gt; 157 0.444 #&gt; 158 0.43 #&gt; 159 0.415 #&gt; 160 0.402 #&gt; 161 0.388 #&gt; 162 0.375 #&gt; 163 0.363 #&gt; 164 0.351 #&gt; 165 0.339 #&gt; 166 0.328 #&gt; 167 0.318 #&gt; 168 0.307 #&gt; 169 0.297 #&gt; 170 0.287 #&gt; 171 0.278 #&gt; 172 0.269 #&gt; 173 0.26 #&gt; 174 0.252 #&gt; 175 0.244 #&gt; 176 0.236 #&gt; 177 0.228 #&gt; 178 0.221 #&gt; 179 0.214 #&gt; 180 0.207 #&gt; 181 0.2 #&gt; 182 0.194 #&gt; 183 0.187 #&gt; 184 0.181 #&gt; 185 0.176 #&gt; 186 0.17 #&gt; 187 0.165 #&gt; 188 0.159 #&gt; 189 0.154 #&gt; 190 0.149 #&gt; 191 0.145 #&gt; 192 0.14 #&gt; 193 0.136 #&gt; 194 0.131 #&gt; 195 0.127 #&gt; 196 0.123 #&gt; 197 0.119 #&gt; 198 0.115 #&gt; 199 0.112 #&gt; 200 0.108 #&gt; 201 0.105 #&gt; 202 0.102 #&gt; 203 0.0983 #&gt; 204 0.0952 #&gt; 205 0.0923 #&gt; 206 0.0894 #&gt; 207 0.0866 #&gt; 208 0.0838 #&gt; 209 0.0812 #&gt; 210 0.0787 #&gt; 211 0.0762 #&gt; 212 0.0739 #&gt; 213 0.0716 #&gt; 214 0.0693 #&gt; 215 0.0672 #&gt; 216 0.0651 #&gt; 217 0.0631 #&gt; 218 0.0611 #&gt; 219 0.0592 #&gt; 220 0.0574 #&gt; 221 0.0556 #&gt; 222 0.0539 #&gt; 223 0.0522 #&gt; 224 0.0506 #&gt; 225 0.0491 #&gt; 226 0.0476 #&gt; 227 0.0461 #&gt; 228 0.0447 #&gt; 229 0.0433 #&gt; 230 0.042 #&gt; 231 0.0407 #&gt; 232 0.0394 #&gt; 233 0.0382 #&gt; 234 0.0371 #&gt; 235 0.0359 #&gt; 236 0.0348 #&gt; 237 0.0338 #&gt; 238 0.0327 #&gt; 239 0.0317 #&gt; 240 0.0308 #&gt; 241 0.0298 #&gt; 242 0.0289 #&gt; 243 0.028 #&gt; 244 0.0272 #&gt; 245 0.0263 #&gt; 246 0.0255 #&gt; 247 0.0248 #&gt; 248 0.024 #&gt; 249 0.0233 #&gt; 250 0.0226 #&gt; 251 0.0219 #&gt; 252 0.0212 #&gt; 253 0.0206 #&gt; 254 0.02 #&gt; 255 0.0194 #&gt; 256 0.0188 #&gt; 257 0.0182 #&gt; 258 0.0177 #&gt; 259 0.0171 #&gt; 260 0.0166 #&gt; 261 0.0161 #&gt; 262 0.0156 #&gt; 263 0.0151 #&gt; 264 0.0147 #&gt; 265 0.0142 #&gt; 266 0.0138 #&gt; 267 0.0134 #&gt; 268 0.013 #&gt; 269 0.0126 #&gt; 270 0.0122 #&gt; 271 0.0119 #&gt; 272 0.0115 #&gt; 273 0.0112 #&gt; 274 0.0108 #&gt; 275 0.0105 #&gt; 276 0.0102 #&gt; 277 0.00988 #&gt; 278 0.00959 #&gt; 279 0.0093 #&gt; 280 0.00902 #&gt; 281 0.00875 #&gt; 282 0.00849 #&gt; 283 0.00824 #&gt; 284 0.00799 #&gt; 285 0.00775 #&gt; 286 0.00752 #&gt; 287 0.0073 #&gt; 288 0.00708 #&gt; 289 0.00687 #&gt; 290 0.00666 #&gt; 291 0.00647 #&gt; 292 0.00627 #&gt; 293 0.00609 #&gt; 294 0.00591 #&gt; 295 0.00573 #&gt; 296 0.00556 #&gt; 297 0.0054 #&gt; 298 0.00524 #&gt; 299 0.00508 #&gt; 300 0.00493 #&gt; 301 0.00478 #&gt; 302 0.00464 #&gt; 303 0.0045 #&gt; 304 0.00437 #&gt; 305 0.00424 #&gt; 306 0.00412 #&gt; 307 0.00399 #&gt; 308 0.00388 #&gt; 309 0.00376 #&gt; 310 0.00365 #&gt; 311 0.00354 #&gt; 312 0.00344 #&gt; 313 0.00334 #&gt; 314 0.00324 #&gt; 315 0.00314 #&gt; 316 0.00305 #&gt; 317 0.00296 #&gt; 318 0.00287 #&gt; 319 0.00279 #&gt; 320 0.00271 #&gt; 321 0.00263 #&gt; 322 0.00255 #&gt; 323 0.00248 #&gt; 324 0.0024 #&gt; 325 0.00233 #&gt; 326 0.00226 #&gt; 327 0.0022 #&gt; 328 0.00213 #&gt; 329 0.00207 #&gt; 330 0.00201 #&gt; 331 0.00195 #&gt; 332 0.00189 #&gt; 333 0.00184 #&gt; 334 0.00178 #&gt; 335 0.00173 #&gt; 336 0.00168 #&gt; 337 0.00163 #&gt; 338 0.00158 #&gt; 339 0.00154 #&gt; 340 0.00149 #&gt; 341 0.00145 #&gt; 342 0.00141 #&gt; 343 0.00137 #&gt; 344 0.00133 #&gt; 345 0.00129 #&gt; 346 0.00125 #&gt; 347 0.00121 #&gt; 348 0.00118 #&gt; 349 0.00114 #&gt; 350 0.00111 #&gt; 351 0.00108 #&gt; 352 0.00105 #&gt; 353 0.00102 #&gt; 354 0.000987 #&gt; 355 0.000958 #&gt; 356 0.000931 #&gt; 357 0.000904 #&gt; 358 0.000877 #&gt; 359 0.000852 #&gt; 360 0.000827 #&gt; 361 0.000803 #&gt; 362 0.00078 #&gt; 363 0.000757 #&gt; 364 0.000735 #&gt; 365 0.000714 #&gt; 366 0.000693 #&gt; 367 0.000673 #&gt; 368 0.000654 #&gt; 369 0.000635 #&gt; 370 0.000617 #&gt; 371 0.000599 #&gt; 372 0.000581 #&gt; 373 0.000565 #&gt; 374 0.000548 #&gt; 375 0.000532 #&gt; 376 0.000517 #&gt; 377 0.000502 #&gt; 378 0.000488 #&gt; 379 0.000474 #&gt; 380 0.00046 #&gt; 381 0.000447 #&gt; 382 0.000434 #&gt; 383 0.000421 #&gt; 384 0.000409 #&gt; 385 0.000397 #&gt; 386 0.000386 #&gt; 387 0.000375 #&gt; 388 0.000364 #&gt; 389 0.000354 #&gt; 390 0.000343 #&gt; 391 0.000334 #&gt; 392 0.000324 #&gt; 393 0.000315 #&gt; 394 0.000306 #&gt; 395 0.000297 #&gt; 396 0.000288 #&gt; 397 0.00028 #&gt; 398 0.000272 #&gt; 399 0.000264 #&gt; 400 0.000257 #&gt; 401 0.000249 #&gt; 402 0.000242 #&gt; 403 0.000235 #&gt; 404 0.000228 #&gt; 405 0.000222 #&gt; 406 0.000216 #&gt; 407 0.000209 #&gt; 408 0.000203 #&gt; 409 0.000198 #&gt; 410 0.000192 #&gt; 411 0.000186 #&gt; 412 0.000181 #&gt; 413 0.000176 #&gt; 414 0.000171 #&gt; 415 0.000166 #&gt; 416 0.000161 #&gt; 417 0.000157 #&gt; 418 0.000152 #&gt; 419 0.000148 #&gt; 420 0.000144 #&gt; 421 0.00014 #&gt; 422 0.000136 #&gt; 423 0.000132 #&gt; 424 0.000128 #&gt; 425 0.000124 #&gt; 426 0.000121 #&gt; 427 0.000117 #&gt; 428 0.000114 #&gt; 429 0.000111 #&gt; 430 0.000108 #&gt; 431 0.000105 #&gt; 432 0.000102 #&gt; 433 9.87e-05 #&gt; 434 9.59e-05 #&gt; 435 9.32e-05 #&gt; 436 9.06e-05 #&gt; 437 8.8e-05 #&gt; 438 8.55e-05 #&gt; 439 8.31e-05 #&gt; 440 8.07e-05 #&gt; 441 7.84e-05 #&gt; 442 7.62e-05 #&gt; 443 7.4e-05 #&gt; 444 7.2e-05 #&gt; 445 6.99e-05 #&gt; 446 6.79e-05 #&gt; 447 6.6e-05 #&gt; 448 6.41e-05 #&gt; 449 6.23e-05 #&gt; 450 6.06e-05 #&gt; 451 5.89e-05 #&gt; 452 5.72e-05 #&gt; 453 5.56e-05 #&gt; 454 5.4e-05 #&gt; 455 5.25e-05 #&gt; 456 5.1e-05 #&gt; 457 4.96e-05 #&gt; 458 4.82e-05 #&gt; 459 4.68e-05 #&gt; 460 4.55e-05 #&gt; 461 4.42e-05 #&gt; 462 4.3e-05 #&gt; 463 4.18e-05 #&gt; 464 4.06e-05 #&gt; 465 3.94e-05 #&gt; 466 3.83e-05 #&gt; 467 3.72e-05 #&gt; 468 3.62e-05 #&gt; 469 3.52e-05 #&gt; 470 3.42e-05 #&gt; 471 3.32e-05 #&gt; 472 3.23e-05 #&gt; 473 3.14e-05 #&gt; 474 3.05e-05 #&gt; 475 2.96e-05 #&gt; 476 2.88e-05 #&gt; 477 2.8e-05 #&gt; 478 2.72e-05 #&gt; 479 2.65e-05 #&gt; 480 2.57e-05 #&gt; 481 2.5e-05 #&gt; 482 2.43e-05 #&gt; 483 2.36e-05 #&gt; 484 2.29e-05 #&gt; 485 2.23e-05 #&gt; 486 2.17e-05 #&gt; 487 2.11e-05 #&gt; 488 2.05e-05 #&gt; 489 1.99e-05 #&gt; 490 1.94e-05 #&gt; 491 1.88e-05 #&gt; 492 1.83e-05 #&gt; 493 1.78e-05 #&gt; 494 1.73e-05 #&gt; 495 1.68e-05 #&gt; 496 1.63e-05 #&gt; 497 1.59e-05 #&gt; 498 1.54e-05 #&gt; 499 1.5e-05 #&gt; 500 1.46e-05 13.7 Using R generics 13.7.1 Simplify tensor operations The following two expressions are equivalent, with the first being the long version natural way of doing it in PyTorch. The second is using the generics in R for subtraction, multiplication and scalar conversion. param$data &lt;- torch$sub(param$data, torch$mul(param$grad$float(), torch$scalar_tensor(learning_rate))) param$data &lt;- param$data - param$grad * learning_rate 13.8 An elegant neural network invisible(torch$manual_seed(0)) # do not show the generator output # layer properties N &lt;- 64L; D_in &lt;- 1000L; H &lt;- 100L; D_out &lt;- 10L # Create random Tensors to hold inputs and outputs x = torch$randn(N, D_in, device=device) y = torch$randn(N, D_out, device=device) # set up the neural network model &lt;- torch$nn$Sequential( torch$nn$Linear(D_in, H), # first layer torch$nn$ReLU(), # activation torch$nn$Linear(H, D_out))$to(device) # output layer # specify how we will be computing the loss loss_fn = torch$nn$MSELoss(reduction = &#39;sum&#39;) learning_rate = 1e-4 loss_row &lt;- list(vector()) # collect a list for the final dataframe for (t in 1:500) { # Forward pass: compute predicted y by passing x to the model. Module objects # override the __call__ operator so you can call them like functions. When # doing so you pass a Tensor of input data to the Module and it produces # a Tensor of output data. y_pred = model(x) # Compute and print loss. We pass Tensors containing the predicted and true # values of y, and the loss function returns a Tensor containing the loss. loss = loss_fn(y_pred, y) # (y_pred - y) is a tensor; loss_fn output is a scalar loss_row[[t]] &lt;- c(t, loss$item()) # Zero the gradients before running the backward pass. model$zero_grad() # Backward pass: compute gradient of the loss with respect to all the learnable # parameters of the model. Internally, the parameters of each module are stored # in tensors with `requires_grad=True`, so this call will compute gradients for # all learnable parameters in the model. loss$backward() # Update the weights using gradient descent. Each parameter is a tensor, so # we can access its data and gradients like we did before. with(torch$no_grad(), { for (param in iterate(model$parameters())) { # using R generics param$data &lt;- param$data - param$grad * learning_rate } }) } 13.9 A browseable dataframe library(DT) loss_df &lt;- data.frame(Reduce(rbind, loss_row), row.names = NULL) names(loss_df)[1] &lt;- &quot;iter&quot; names(loss_df)[2] &lt;- &quot;loss&quot; DT::datatable(loss_df) 13.10 Plot the loss at each iteration library(ggplot2) # plot ggplot(loss_df, aes(x = iter, y = loss)) + geom_point() "],["working-with-a-data-frame.html", "Chapter 14 Working with a data.frame 14.1 Load PyTorch libraries 14.2 Load dataset 14.3 Summary statistics for tensors", " Chapter 14 Working with a data.frame Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 14.1 Load PyTorch libraries library(rTorch) torch &lt;- import(&quot;torch&quot;) torchvision &lt;- import(&quot;torchvision&quot;) nn &lt;- import(&quot;torch.nn&quot;) transforms &lt;- import(&quot;torchvision.transforms&quot;) dsets &lt;- import(&quot;torchvision.datasets&quot;) builtins &lt;- import_builtins() np &lt;- import(&quot;numpy&quot;) 14.2 Load dataset # folders where the images are located train_data_path = &#39;./mnist_png_full/training/&#39; test_data_path = &#39;./mnist_png_full/testing/&#39; # read the datasets without normalization train_dataset = torchvision$datasets$ImageFolder(root = train_data_path, transform = torchvision$transforms$ToTensor() ) print(train_dataset) #&gt; Dataset ImageFolder #&gt; Number of datapoints: 60000 #&gt; Root location: ./mnist_png_full/training/ #&gt; StandardTransform #&gt; Transform: ToTensor() 14.3 Summary statistics for tensors 14.3.1 Using data.frame library(tictoc) tic() fun_list &lt;- list( size = c(&quot;size&quot;), numel = c(&quot;numel&quot;), sum = c(&quot;sum&quot;, &quot;item&quot;), mean = c(&quot;mean&quot;, &quot;item&quot;), std = c(&quot;std&quot;, &quot;item&quot;), med = c(&quot;median&quot;, &quot;item&quot;), max = c(&quot;max&quot;, &quot;item&quot;), min = c(&quot;min&quot;, &quot;item&quot;) ) idx &lt;- seq(0L, 599L) # how many samples fun_get_tensor &lt;- function(x) py_get_item(train_dataset, x)[[0]] stat_fun &lt;- function(x, str_fun) { fun_var &lt;- paste0(&quot;fun_get_tensor(x)&quot;, &quot;$&quot;, str_fun, &quot;()&quot;) sapply(idx, function(x) ifelse(is.numeric(eval(parse(text = fun_var))), # size return chracater eval(parse(text = fun_var)), # all else are numeric as.character(eval(parse(text = fun_var))))) } df &lt;- data.frame(ridx = idx+1, # index number for the sample do.call(data.frame, lapply( sapply(fun_list, function(x) paste(x, collapse = &quot;()$&quot;)), function(y) stat_fun(1, y) ) ) ) Summary statistics: head(df, 20) #&gt; ridx size numel sum mean std med max min #&gt; 1 1 torch.Size([3, 28, 28]) 2352 366 0.156 0.329 0 1.000 0 #&gt; 2 2 torch.Size([3, 28, 28]) 2352 284 0.121 0.297 0 1.000 0 #&gt; 3 3 torch.Size([3, 28, 28]) 2352 645 0.274 0.420 0 1.000 0 #&gt; 4 4 torch.Size([3, 28, 28]) 2352 410 0.174 0.355 0 1.000 0 #&gt; 5 5 torch.Size([3, 28, 28]) 2352 321 0.137 0.312 0 1.000 0 #&gt; 6 6 torch.Size([3, 28, 28]) 2352 654 0.278 0.421 0 1.000 0 #&gt; 7 7 torch.Size([3, 28, 28]) 2352 496 0.211 0.374 0 1.000 0 #&gt; 8 8 torch.Size([3, 28, 28]) 2352 549 0.233 0.399 0 1.000 0 #&gt; 9 9 torch.Size([3, 28, 28]) 2352 449 0.191 0.365 0 1.000 0 #&gt; 10 10 torch.Size([3, 28, 28]) 2352 465 0.198 0.367 0 1.000 0 #&gt; 11 11 torch.Size([3, 28, 28]) 2352 383 0.163 0.338 0 1.000 0 #&gt; 12 12 torch.Size([3, 28, 28]) 2352 499 0.212 0.378 0 1.000 0 #&gt; 13 13 torch.Size([3, 28, 28]) 2352 313 0.133 0.309 0 0.996 0 #&gt; 14 14 torch.Size([3, 28, 28]) 2352 360 0.153 0.325 0 1.000 0 #&gt; 15 15 torch.Size([3, 28, 28]) 2352 435 0.185 0.358 0 0.996 0 #&gt; 16 16 torch.Size([3, 28, 28]) 2352 429 0.182 0.358 0 1.000 0 #&gt; 17 17 torch.Size([3, 28, 28]) 2352 596 0.254 0.408 0 1.000 0 #&gt; 18 18 torch.Size([3, 28, 28]) 2352 527 0.224 0.392 0 1.000 0 #&gt; 19 19 torch.Size([3, 28, 28]) 2352 303 0.129 0.301 0 1.000 0 #&gt; 20 20 torch.Size([3, 28, 28]) 2352 458 0.195 0.364 0 1.000 0 Elapsed time per size of sample: toc() # 60 1.663s # 600 13.5s # 6000 54.321 sec; # 60000 553.489 sec elapsed #&gt; 11.319 sec elapsed "],["working-with-data-table.html", "Chapter 15 Working with data.table 15.1 Load PyTorch libraries 15.2 Load dataset 15.3 Datasets without normalization 15.4 Using data.table", " Chapter 15 Working with data.table Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) 15.1 Load PyTorch libraries library(rTorch) torch &lt;- import(&quot;torch&quot;) torchvision &lt;- import(&quot;torchvision&quot;) nn &lt;- import(&quot;torch.nn&quot;) transforms &lt;- import(&quot;torchvision.transforms&quot;) dsets &lt;- import(&quot;torchvision.datasets&quot;) builtins &lt;- import_builtins() np &lt;- import(&quot;numpy&quot;) 15.2 Load dataset ## Dataset iteration batch settings # folders where the images are located train_data_path = &#39;./mnist_png_full/training/&#39; test_data_path = &#39;./mnist_png_full/testing/&#39; 15.3 Datasets without normalization train_dataset = torchvision$datasets$ImageFolder(root = train_data_path, transform = torchvision$transforms$ToTensor() ) print(train_dataset) #&gt; Dataset ImageFolder #&gt; Number of datapoints: 60000 #&gt; Root location: ./mnist_png_full/training/ #&gt; StandardTransform #&gt; Transform: ToTensor() 15.4 Using data.table library(data.table) library(tictoc) tic() fun_list &lt;- list( numel = c(&quot;numel&quot;), sum = c(&quot;sum&quot;, &quot;item&quot;), mean = c(&quot;mean&quot;, &quot;item&quot;), std = c(&quot;std&quot;, &quot;item&quot;), med = c(&quot;median&quot;, &quot;item&quot;), max = c(&quot;max&quot;, &quot;item&quot;), min = c(&quot;min&quot;, &quot;item&quot;) ) idx &lt;- seq(0L, 599L) fun_get_tensor &lt;- function(x) py_get_item(train_dataset, x)[[0]] stat_fun &lt;- function(x, str_fun) { fun_var &lt;- paste0(&quot;fun_get_tensor(x)&quot;, &quot;$&quot;, str_fun, &quot;()&quot;) sapply(idx, function(x) ifelse(is.numeric(eval(parse(text = fun_var))), # size return character eval(parse(text = fun_var)), # all else are numeric as.character(eval(parse(text = fun_var))))) } dt &lt;- data.table(ridx = idx+1, do.call(data.table, lapply( sapply(fun_list, function(x) paste(x, collapse = &quot;()$&quot;)), function(y) stat_fun(1, y) ) ) ) Summary statistics: head(dt) #&gt; ridx numel sum mean std med max min #&gt; 1: 1 2352 366 0.156 0.329 0 1 0 #&gt; 2: 2 2352 284 0.121 0.297 0 1 0 #&gt; 3: 3 2352 645 0.274 0.420 0 1 0 #&gt; 4: 4 2352 410 0.174 0.355 0 1 0 #&gt; 5: 5 2352 321 0.137 0.312 0 1 0 #&gt; 6: 6 2352 654 0.278 0.421 0 1 0 Elapsed time per size of sample: toc() # 60 1.266 sec elapsed # 600 11.798 sec elapsed; # 6000 119.256 sec elapsed; # 60000 1117.619 sec elapsed #&gt; 9.574 sec elapsed "],["appendixA.html", "A Statistical Background A.1 Basic statistical terms", " A Statistical Background Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) A.1 Basic statistical terms A.1.1 Five-number summary The five-number summary consists of five values: minimum, first quantile, second quantile, third quantile, and maximum. The quantiles are calculated as: first quantile (\\(Q_1\\)): the median of the first half of the sorted data third quantile (\\(Q_3\\)): the median of the second half of the sorted data First quantile: 25th percentile. Second quantile: 50th percentile. Third quantile: 75th percentile. The interquartile range or IQR is defined as \\(Q_3 - Q_1\\) and is a measure of how spread out the middle 50% of values is. "],["appendixB.html", "B Activation Functions B.1 Sigmoid B.2 ReLU B.3 tanh B.4 Softmax B.5 Activation functions in Python B.6 Softmax code in Python", " B Activation Functions Last update: Thu Oct 22 16:46:28 2020 -0500 (54a46ea04) library(rTorch) library(ggplot2) B.1 Sigmoid Using the PyTorch sigmoid() function: x &lt;- torch$range(-5., 5., 0.1) y &lt;- torch$sigmoid(x) df &lt;- data.frame(x = x$numpy(), sx = y$numpy()) df ggplot(df, aes(x = x, y = sx)) + geom_point() + ggtitle(&quot;Sigmoid&quot;) #&gt; x sx #&gt; 1 -5.0 0.00669 #&gt; 2 -4.9 0.00739 #&gt; 3 -4.8 0.00816 #&gt; 4 -4.7 0.00901 #&gt; 5 -4.6 0.00995 #&gt; 6 -4.5 0.01099 #&gt; 7 -4.4 0.01213 #&gt; 8 -4.3 0.01339 #&gt; 9 -4.2 0.01477 #&gt; 10 -4.1 0.01630 #&gt; 11 -4.0 0.01799 #&gt; 12 -3.9 0.01984 #&gt; 13 -3.8 0.02188 #&gt; 14 -3.7 0.02413 #&gt; 15 -3.6 0.02660 #&gt; 16 -3.5 0.02931 #&gt; 17 -3.4 0.03230 #&gt; 18 -3.3 0.03557 #&gt; 19 -3.2 0.03917 #&gt; 20 -3.1 0.04311 #&gt; 21 -3.0 0.04743 #&gt; 22 -2.9 0.05215 #&gt; 23 -2.8 0.05732 #&gt; 24 -2.7 0.06297 #&gt; 25 -2.6 0.06914 #&gt; 26 -2.5 0.07586 #&gt; 27 -2.4 0.08317 #&gt; 28 -2.3 0.09112 #&gt; 29 -2.2 0.09975 #&gt; 30 -2.1 0.10910 #&gt; 31 -2.0 0.11920 #&gt; 32 -1.9 0.13011 #&gt; 33 -1.8 0.14185 #&gt; 34 -1.7 0.15447 #&gt; 35 -1.6 0.16798 #&gt; 36 -1.5 0.18243 #&gt; 37 -1.4 0.19782 #&gt; 38 -1.3 0.21417 #&gt; 39 -1.2 0.23148 #&gt; 40 -1.1 0.24974 #&gt; 41 -1.0 0.26894 #&gt; 42 -0.9 0.28905 #&gt; 43 -0.8 0.31003 #&gt; 44 -0.7 0.33181 #&gt; 45 -0.6 0.35434 #&gt; 46 -0.5 0.37754 #&gt; 47 -0.4 0.40131 #&gt; 48 -0.3 0.42556 #&gt; 49 -0.2 0.45017 #&gt; 50 -0.1 0.47502 #&gt; 51 0.0 0.50000 #&gt; 52 0.1 0.52498 #&gt; 53 0.2 0.54983 #&gt; 54 0.3 0.57444 #&gt; 55 0.4 0.59869 #&gt; 56 0.5 0.62246 #&gt; 57 0.6 0.64566 #&gt; 58 0.7 0.66819 #&gt; 59 0.8 0.68997 #&gt; 60 0.9 0.71095 #&gt; 61 1.0 0.73106 #&gt; 62 1.1 0.75026 #&gt; 63 1.2 0.76852 #&gt; 64 1.3 0.78584 #&gt; 65 1.4 0.80218 #&gt; 66 1.5 0.81757 #&gt; 67 1.6 0.83202 #&gt; 68 1.7 0.84553 #&gt; 69 1.8 0.85815 #&gt; 70 1.9 0.86989 #&gt; 71 2.0 0.88080 #&gt; 72 2.1 0.89090 #&gt; 73 2.2 0.90025 #&gt; 74 2.3 0.90888 #&gt; 75 2.4 0.91683 #&gt; 76 2.5 0.92414 #&gt; 77 2.6 0.93086 #&gt; 78 2.7 0.93703 #&gt; 79 2.8 0.94268 #&gt; 80 2.9 0.94785 #&gt; 81 3.0 0.95257 #&gt; 82 3.1 0.95689 #&gt; 83 3.2 0.96083 #&gt; 84 3.3 0.96443 #&gt; 85 3.4 0.96770 #&gt; 86 3.5 0.97069 #&gt; 87 3.6 0.97340 #&gt; 88 3.7 0.97587 #&gt; 89 3.8 0.97812 #&gt; 90 3.9 0.98016 #&gt; 91 4.0 0.98201 #&gt; 92 4.1 0.98370 #&gt; 93 4.2 0.98523 #&gt; 94 4.3 0.98661 #&gt; 95 4.4 0.98787 #&gt; 96 4.5 0.98901 #&gt; 97 4.6 0.99005 #&gt; 98 4.7 0.99099 #&gt; 99 4.8 0.99184 #&gt; 100 4.9 0.99261 #&gt; 101 5.0 0.99331 Plot the sigmoid function using an R custom-made function: sigmoid = function(x) { 1 / (1 + exp(-x)) } x &lt;- seq(-5, 5, 0.01) plot(x, sigmoid(x), col = &#39;blue&#39;, cex = 0.5, main = &quot;Sigmoid&quot;) B.2 ReLU Using the PyTorch relu() function: x &lt;- torch$range(-5., 5., 0.1) y &lt;- torch$relu(x) df &lt;- data.frame(x = x$numpy(), sx = y$numpy()) df ggplot(df, aes(x = x, y = sx)) + geom_point() + ggtitle(&quot;ReLU&quot;) B.3 tanh Using the PyTorch tanh() function: x &lt;- torch$range(-5., 5., 0.1) y &lt;- torch$tanh(x) df &lt;- data.frame(x = x$numpy(), sx = y$numpy()) df ggplot(df, aes(x = x, y = sx)) + geom_point() + ggtitle(&quot;tanh&quot;) B.4 Softmax Using the PyTorch softmax() function: x &lt;- torch$range(-5.0, 5.0, 0.1) y &lt;- torch$softmax(x, dim=0L) df &lt;- data.frame(x = x$numpy(), sx = y$numpy()) ggplot(df, aes(x = x, y = sx)) + geom_point() + ggtitle(&quot;Softmax&quot;) B.5 Activation functions in Python library(rTorch) import numpy as np import matplotlib.pyplot as plt np.random.seed(42) Linear activation def Linear(x, derivative=False): &quot;&quot;&quot; Computes the Linear activation function for array x inputs: x: array derivative: if True, return the derivative else the forward pass &quot;&quot;&quot; if derivative: # Return derivative of the function at x return np.ones_like(x) else: # Return forward pass of the function at x return x Sigmoid activation def Sigmoid(x, derivative=False): &quot;&quot;&quot; Computes the Sigmoid activation function for array x inputs: x: array derivative: if True, return the derivative else the forward pass &quot;&quot;&quot; f = 1/(1+np.exp(-x)) if derivative: # Return derivative of the function at x return f*(1-f) else: # Return forward pass of the function at x return f Hyperbolic Tangent activation def Tanh(x, derivative=False): &quot;&quot;&quot; Computes the Hyperbolic Tangent activation function for array x inputs: x: array derivative: if True, return the derivative else the forward pass &quot;&quot;&quot; f = (np.exp(x)-np.exp(-x))/(np.exp(x)+np.exp(-x)) if derivative: # Return derivative of the function at x return 1-f**2 else: # Return the forward pass of the function at x return f Rectifier linear unit (ReLU) def ReLU(x, derivative=False): &quot;&quot;&quot; Computes the Rectifier Linear Unit activation function for array x inputs: x: array derivative: if True, return the derivative else the forward pass &quot;&quot;&quot; if derivative: # Return derivative of the function at x return (x&gt;0).astype(int) else: # Return forward pass of the function at x return np.maximum(x, 0) Visualization with matplotlib Plotting using matplotlib: x = np.linspace(-6, 6, 100) units = { &quot;Linear&quot;: lambda x: Linear(x), &quot;Sigmoid&quot;: lambda x: Sigmoid(x), &quot;ReLU&quot;: lambda x: ReLU(x), &quot;tanh&quot;: lambda x: Tanh(x) } plt.figure(figsize=(5, 5)) [plt.plot(x, unit(x), label=unit_name, lw=2) for unit_name, unit in units.items()] plt.legend(loc=2, fontsize=16) plt.title(&#39;Activation functions&#39;, fontsize=20) plt.ylim([-2, 5]) plt.xlim([-6, 6]) plt.show() B.6 Softmax code in Python # Source: https://dataaspirant.com/2017/03/07/difference-between-softmax-function-and-sigmoid-function/ import numpy as np import matplotlib.pyplot as plt def softmax(inputs): &quot;&quot;&quot; Calculate the softmax for the give inputs (array) :param inputs: :return: &quot;&quot;&quot; return np.exp(inputs) / float(sum(np.exp(inputs))) def line_graph(x, y, x_title, y_title): &quot;&quot;&quot; Draw line graph with x and y values :param x: :param y: :param x_title: :param y_title: :return: &quot;&quot;&quot; plt.plot(x, y) plt.xlabel(x_title) plt.ylabel(y_title) plt.show() graph_x = np.linspace(-6, 6, 100) graph_y = softmax(graph_x) print(&quot;Graph X readings: {}&quot;.format(graph_x)) print(&quot;Graph Y readings: {}&quot;.format(graph_y)) line_graph(graph_x, graph_y, &quot;Inputs&quot;, &quot;Softmax Scores&quot;) "],["references.html", "References", " References "]]
